var searchIndex = JSON.parse('{\
"base_conversion":{"doc":"","i":[[5,"lookup_digits_mod_at_position","base_conversion","",null,[[]]],[5,"lookup_defined_for_mod","","",null,[[]]]],"p":[]},\
"fancy_garbling":{"doc":"`fancy-garbling` provides boolean and arithmetic garbling…","i":[[3,"BinaryBundle","fancy_garbling","Bundle which is explicitly binary representation.",null,null],[3,"Bundle","","A collection of wires, useful for the garbled gadgets…",null,null],[3,"CrtBundle","","Bundle which is explicitly CRT-representation.",null,null],[3,"Evaluator","","Streaming evaluator using a callback to receive…",null,null],[3,"Garbler","","Streams garbled circuit ciphertexts through a callback.",null,null],[4,"Wire","","The core wire-label type.",null,null],[13,"Mod2","","Representation of a `mod-2` wire.",0,null],[12,"val","fancy_garbling::Wire","A 128-bit value.",1,null],[13,"Mod3","fancy_garbling","Representation of a `mod-3` wire.",0,null],[12,"lsb","fancy_garbling::Wire","The least-significant bits of each `mod-3` element.",2,null],[12,"msb","","The most-significant bits of each `mod-3` element.",2,null],[13,"ModN","fancy_garbling","Representation of a `mod-q` wire.",0,null],[12,"q","fancy_garbling::Wire","The modulus of this wire-label.",3,null],[12,"ds","","A list of `mod-q` digits.",3,null],[0,"circuit","fancy_garbling","DSL for creating circuits compatible with fancy-garbling…",null,null],[3,"CircuitRef","fancy_garbling::circuit","The index and modulus of a gate in a circuit.",null,null],[3,"Circuit","","Static representation of the type of computation supported…",null,null],[3,"CircuitBuilder","","CircuitBuilder is used to build circuits.",null,null],[11,"new","","Make a new `Circuit` object.",4,[[["option",4]],["circuit",3]]],[11,"eval","","Evaluate the circuit using fancy object `f`.",4,[[],[["option",4],["result",4]]]],[11,"eval_plain","","Evaluate the circuit in plaintext.",4,[[],[["vec",3],["result",4],["dummyerror",4]]]],[11,"print_info","","Print circuit info.",4,[[],[["result",4],["dummyerror",4]]]],[11,"num_garbler_inputs","","Return the number of garbler inputs.",4,[[]]],[11,"num_evaluator_inputs","","Return the number of evaluator inputs.",4,[[]]],[11,"noutputs","","Return the number of outputs.",4,[[]]],[11,"modulus","","Return the modulus of the gate indexed by `i`.",4,[[]]],[11,"garbler_input_mod","","Return the modulus of the garbler input indexed by `i`.",4,[[]]],[11,"evaluator_input_mod","","Return the modulus of the evaluator input indexed by `i`.",4,[[]]],[11,"new","","Make a new `CircuitBuilder`.",5,[[]]],[11,"finish","","Finish circuit building, outputting the resulting circuit.",5,[[],["circuit",3]]],[11,"garbler_input","","Get CircuitRef for a garbler input wire.",5,[[],["circuitref",3]]],[11,"evaluator_input","","Get CircuitRef for an evaluator input wire.",5,[[],["circuitref",3]]],[11,"garbler_inputs","","Get a vec of CircuitRefs for garbler inputs.",5,[[],[["vec",3],["circuitref",3]]]],[11,"evaluator_inputs","","Get a vec of CircuitRefs for garbler inputs.",5,[[],[["vec",3],["circuitref",3]]]],[11,"crt_garbler_input","","Get a CrtBundle for the garbler using composite modulus Q",5,[[],[["crtbundle",3],["circuitref",3]]]],[11,"crt_evaluator_input","","Get a CrtBundle for the evaluator using composite modulus Q",5,[[],[["crtbundle",3],["circuitref",3]]]],[11,"bin_garbler_input","","Get a BinaryBundle for the garbler with n bits.",5,[[],[["binarybundle",3],["circuitref",3]]]],[11,"bin_evaluator_input","","Get a BinaryBundle for the evaluator with n bits.",5,[[],[["binarybundle",3],["circuitref",3]]]],[0,"classic","fancy_garbling","Provides objects and functions for statically garbling and…",null,null],[3,"GarbledCircuit","fancy_garbling::classic","Static evaluator for a circuit, created by the `garble`…",null,null],[3,"Encoder","","Encode inputs statically.",null,null],[5,"garble","","Garble a circuit without streaming.",null,[[["circuit",3]],[["garblererror",4],["result",4]]]],[11,"new","","Create a new object from a vector of garbled data",6,[[["vec",3]]]],[11,"size","","The number of bytes in the garbled circuit.",6,[[]]],[11,"eval","","Evaluate the garbled circuit.",6,[[["circuit",3]],[["vec",3],["result",4],["evaluatorerror",4]]]],[11,"new","","Make a new `Encoder` from lists of garbler and evaluator…",7,[[["vec",3],["wire",4],["hashmap",3]]]],[11,"num_garbler_inputs","","Output the number of garbler inputs.",7,[[]]],[11,"num_evaluator_inputs","","Output the number of evaluator inputs.",7,[[]]],[11,"encode_garbler_input","","Encode a single garbler input into its associated…",7,[[],["wire",4]]],[11,"encode_evaluator_input","","Encode a single evaluator input into its associated…",7,[[],["wire",4]]],[11,"encode_garbler_inputs","","Encode a slice of garbler inputs into their associated…",7,[[],[["vec",3],["wire",4]]]],[11,"encode_evaluator_inputs","","Encode a slice of evaluator inputs into their associated…",7,[[],[["vec",3],["wire",4]]]],[0,"dummy","fancy_garbling","Dummy implementation of `Fancy`.",null,null],[3,"Dummy","fancy_garbling::dummy","Simple struct that performs the fancy computation over…",null,null],[3,"DummyVal","","Wrapper around `u16`.",null,null],[11,"new","","Create a new DummyVal.",8,[[]]],[11,"val","","Extract the value.",8,[[]]],[11,"new","","Create a new Dummy.",9,[[],["dummy",3]]],[0,"errors","fancy_garbling","Errors that may be output by this library.",null,null],[4,"FancyError","fancy_garbling::errors","Errors that may occur when using the `Fancy` trait. These…",null,null],[13,"UnequalModuli","","Unequal moduli.",10,null],[13,"InvalidArg","","Invalid argument.",10,null],[13,"InvalidArgNum","","Invalid number of arguments.",10,null],[12,"got","fancy_garbling::errors::FancyError","Received number of arguments.",11,null],[12,"needed","","Expected number of arguments.",11,null],[13,"InvalidArgMod","fancy_garbling::errors","Invalid argument modulus.",10,null],[12,"got","fancy_garbling::errors::FancyError","Received modulus.",12,null],[12,"needed","","Expected modulus.",12,null],[13,"ArgNotBinary","fancy_garbling::errors","Expected binary argument.",10,null],[13,"NoTruthTable","","Truth table expected but none given.",10,null],[13,"InvalidTruthTable","","Projection truth table is invalid.",10,null],[13,"UninitializedValue","","Uninitialized value encountered.",10,null],[4,"DummyError","","Errors from the dummy fancy object.",null,null],[13,"NotEnoughGarblerInputs","","Not enough garbler inputs provided.",13,null],[13,"NotEnoughEvaluatorInputs","","Not enough evaluator inputs provided.",13,null],[13,"EncodingError","","Encoding error.",13,null],[13,"FancyError","","A fancy error has occurred.",13,null],[4,"EvaluatorError","","Errors from the evaluator.",null,null],[13,"NotEnoughGarblerInputs","","Not enough garbler inputs provided.",14,null],[13,"NotEnoughEvaluatorInputs","","Not enough evaluator inputs provided.",14,null],[13,"DecodingFailed","","Decoding failed.",14,null],[13,"CommunicationError","","A communication error has occurred.",14,null],[13,"FancyError","","A fancy error has occurred.",14,null],[4,"GarblerError","","Errors from the garbler.",null,null],[13,"CommunicationError","","An error occurred while processing a message.",15,null],[13,"AsymmetricHalfGateModuliMax8","","Asymmetric moduli error.",15,null],[13,"TruthTableRequired","","A truth table was missing.",15,null],[13,"DeltaRequired","","Delta required for wire reuse.",15,null],[13,"EncodingError","","Encoding error.",15,null],[13,"FancyError","","A fancy error has occurred.",15,null],[4,"CircuitBuilderError","","Errors emitted when building a circuit.",null,null],[13,"ReuseUndefined","","Reuse not supported.",16,null],[13,"FancyError","","A fancy error has occurred.",16,null],[4,"CircuitParserError","","Errors emitted by the circuit parser.",null,null],[13,"IoError","","An I/O error occurred.",17,null],[13,"RegexError","","A regular expression parsing error occurred.",17,null],[13,"ParseIntError","","An error occurred parsing an integer.",17,null],[13,"ParseLineError","","An error occurred parsing a line.",17,null],[13,"ParseGateError","","An error occurred parsing a gate type.",17,null],[4,"TwopacError","","Errors produced by `twopac`.",null,null],[13,"IoError","","An I/O error has occurred.",18,null],[13,"OtError","","An oblivious transfer error has occurred.",18,null],[13,"GarblerError","","The garbler produced an error.",18,null],[13,"EvaluatorError","","The evaluator produced an error.",18,null],[13,"FancyError","","Processing the garbled circuit produced an error.",18,null],[11,"new","fancy_garbling","Create a new binary bundle from a vector of wires.",19,[[["vec",3]],["binarybundle",3]]],[11,"extract","","Extract the underlying bundle from this binary bundle.",19,[[],["bundle",3]]],[11,"new","","Create a new bundle from some wires.",20,[[["vec",3]],["bundle",3]]],[11,"moduli","","Return the moduli of all the wires in the bundle.",20,[[],["vec",3]]],[11,"wires","","Extract the wires from this bundle.",20,[[]]],[11,"size","","Get the number of wires in this bundle.",20,[[]]],[11,"is_binary","","Whether this bundle only contains residues in mod 2.",20,[[]]],[11,"with_moduli","","Returns a new bundle only containing wires with matching…",20,[[],["bundle",3]]],[11,"pad","","Pad the Bundle with val, n times.",20,[[]]],[11,"extract","","Extract a wire from the Bundle, removing it and returning…",20,[[]]],[11,"iter","","Access the underlying iterator",20,[[],["iter",3]]],[11,"new","","Create a new CRT bundle from a vector of wires.",21,[[["vec",3]],["crtbundle",3]]],[11,"extract","","Extract the underlying bundle from this CRT bundle.",21,[[],["bundle",3]]],[11,"composite_modulus","","Return the product of all the wires\' moduli.",21,[[]]],[11,"new","","Create a new `Evaluator`.",22,[[]]],[11,"get_channel","","Get the communication channel used to talk to the…",22,[[]]],[11,"read_wire","","Read a Wire from the reader.",22,[[],[["evaluatorerror",4],["result",4],["wire",4]]]],[11,"new","","Create a new garbler.",23,[[]]],[11,"get_channel","","Get the communication channel used to talk to the…",23,[[]]],[11,"delta","","Create a delta if it has not been created yet for this…",23,[[],["wire",4]]],[11,"get_deltas","","Get the deltas, consuming the Garbler.",23,[[],[["wire",4],["hashmap",3]]]],[11,"send_wire","","Send a wire over the established channel.",23,[[["wire",4]],[["garblererror",4],["result",4]]]],[11,"create_wire","","Create a wire, producing the zero wire.",23,[[],["wire",4]]],[11,"encode_wire","","Encode a wire, producing the zero wire as well as the…",23,[[]]],[11,"encode_many_wires","","Encode many wires, producing zero wires as well as encoded…",23,[[],[["garblererror",4],["result",4]]]],[11,"crt_encode_wire","","Encode a `CrtBundle`, producing zero wires as well as…",23,[[],[["garblererror",4],["result",4]]]],[11,"bin_encode_wire","","Encode a `BinaryBundle`, producing zero wires as well as…",23,[[],[["garblererror",4],["result",4]]]],[0,"informer","","`Informer` runs a fancy computation and learns information…",null,null],[3,"Informer","fancy_garbling::informer","Implements `Fancy`. Used to learn information about a…",null,null],[12,"underlying","","The underlying fancy object.",24,null],[3,"InformerStats","","The statistics revealed by the informer.",null,null],[11,"num_garbler_inputs","","Number of garbler inputs in the fancy computation.",25,[[]]],[11,"garbler_input_moduli","","Moduli of garbler inputs in the fancy computation.",25,[[],["vec",3]]],[11,"num_evaluator_inputs","","Number of evaluator inputs in the fancy computation.",25,[[]]],[11,"evaluator_input_moduli","","Moduli of evaluator inputs in the fancy computation.",25,[[],["vec",3]]],[11,"num_consts","","Number of constants in the fancy computation.",25,[[]]],[11,"num_outputs","","Number of outputs in the fancy computation.",25,[[]]],[11,"num_output_ciphertexts","","Number of output ciphertexts.",25,[[]]],[11,"num_adds","","Number of additions in the fancy computation.",25,[[]]],[11,"num_subs","","Number of subtractions in the fancy computation.",25,[[]]],[11,"num_cmuls","","Number of scalar multiplications in the fancy computation.",25,[[]]],[11,"num_muls","","Number of multiplications in the fancy computation.",25,[[]]],[11,"num_projs","","Number of projections in the fancy computation.",25,[[]]],[11,"num_ciphertexts","","Number of ciphertexts in the fancy computation.",25,[[]]],[11,"new","","Make a new `Informer`.",24,[[],["informer",3]]],[11,"stats","","Get the statistics collected by the `Informer`",24,[[],["informerstats",3]]],[11,"parse","fancy_garbling::circuit","Generates a new `Circuit` from file `filename`. The file…",4,[[],[["result",4],["error",4]]]],[0,"twopac","fancy_garbling","Implementations of two-party secure computation.",null,null],[0,"semihonest","fancy_garbling::twopac","Implementation of semi-honest two-party computation.",null,null],[3,"Evaluator","fancy_garbling::twopac::semihonest","Semi-honest evaluator.",null,null],[3,"Garbler","","Semi-honest garbler.",null,null],[4,"PartyId","","The parties in this two-party computation protocol.",null,null],[13,"Garbler","","The `Garbler` party.",26,null],[13,"Evaluator","","The `Evaluator` party.",26,null],[11,"new","","Make a new `Evaluator`.",27,[[],[["result",4],["twopacerror",4]]]],[11,"get_channel","","Get a reference to the internal channel.",27,[[]]],[11,"new","","Make a new `Garbler`.",28,[[],[["result",4],["twopacerror",4]]]],[11,"get_channel","","Get a reference to the internal channel.",28,[[]]],[0,"threepac","fancy_garbling","Implementations of three-party secure computation.",null,null],[0,"malicious","fancy_garbling::threepac","Implementation of honest majority three-party malicous…",null,null],[4,"PartyId","fancy_garbling::threepac::malicious","Identify a participant in the garbled circuit protocol.…",null,null],[13,"Garbler1","","",29,null],[13,"Garbler2","","",29,null],[13,"Evaluator","","",29,null],[0,"evaluator","","",null,null],[3,"Evaluator","fancy_garbling::threepac::malicious::evaluator","Honest majority three party evaluator. Implementation of…",null,null],[4,"Error","","Errors produced by `threepac` Evaluator.",null,null],[13,"IoError","","An I/O error has occurred.",30,null],[13,"EvaluatorError","","The underlying garbler produced an error.",30,null],[13,"FancyError","","Processing the garbled circuit produced an error.",30,null],[13,"GarblerMismatch","","Garblers sent different values. One may be malicious!!!",30,null],[13,"InvalidCommitment","","Garbler committed to one value, then sent a different one.",30,null],[11,"new","","Make a new `Evaluator`. The protocol calls for two…",31,[[],[["error",4],["result",4]]]],[11,"get_channel_garbler_1","","Get communication channel with Garbler 1",31,[[]]],[11,"get_channel_garbler_2","","Get communication channel with Garbler 2",31,[[]]],[0,"garbler","fancy_garbling::threepac::malicious","",null,null],[3,"Garbler","fancy_garbling::threepac::malicious::garbler","Honest majority three party garbler. Implementation of…",null,null],[4,"Error","","Errors produced by `threepac` Garbler.",null,null],[13,"IoError","","An I/O error has occurred.",32,null],[13,"GarblerError","","The underlying garbler produced an error.",32,null],[13,"FancyError","","Processing the garbled circuit produced an error.",32,null],[13,"InvalidResult","","Evaluator may be malicious!!!",32,null],[11,"new","","Make a new `Garbler`. The protocol calls for two…",33,[[["partyid",4]],[["result",4],["error",4]]]],[11,"get_channel","","Get the channel used to talk to the evaluator.",33,[[]]],[0,"util","fancy_garbling","Tools useful for interacting with `fancy-garbling`.",null,null],[5,"tweak","fancy_garbling::util","Tweak function for a single item.",null,[[],["block",3]]],[5,"tweak2","","Tweak function for two items.",null,[[],["block",3]]],[5,"base_q_add_eq","","Add a base `q` slice `ys` into `xs`.",null,[[]]],[5,"digits_per_u128","","Determine how many `mod q` digits fit into a `u128`…",null,[[]]],[5,"as_base_q_u128","","Convert `x` into base `q`.",null,[[],["vec",3]]],[5,"as_mixed_radix","","Convert `x` into mixed radix form using the provided…",null,[[],["vec",3]]],[5,"from_base_q","","Convert little-endian base `q` digits into `u128`.",null,[[]]],[5,"from_mixed_radix","","Convert little-endian mixed radix digits into u128.",null,[[]]],[5,"u128_to_bits","","Get the bits of a u128 encoded in 128 u16s, which is…",null,[[],["vec",3]]],[5,"u128_from_bits","","Convert into a u128 from the \\\"bits\\\" as u16. Assumes each…",null,[[]]],[5,"factor","","Factor using the primes in the global `PRIMES` array.…",null,[[],["vec",3]]],[5,"crt","","Compute the CRT representation of x with respect to the…",null,[[],["vec",3]]],[5,"crt_factor","","Compute the CRT representation of `x` with respect to the…",null,[[],["vec",3]]],[5,"crt_inv","","Compute the value x given a list of CRT primes and residues.",null,[[]]],[5,"crt_inv_factor","","Compute the value `x` given a composite CRT modulus…",null,[[]]],[5,"inv","","Generic algorithm to invert inp_a mod inp_b. As ref so as…",null,[[]]],[5,"modulus_with_nprimes","","Primes skipping the modulus 2, which allows certain…",null,[[]]],[5,"modulus_with_width","","Generate a CRT modulus that support at least n-bit…",null,[[]]],[5,"primes_with_width","","Generate the factors of a CRT modulus that support at…",null,[[],["vec",3]]],[5,"base_modulus_with_width","","Generate a CRT modulus that support at least n-bit…",null,[[]]],[5,"base_primes_with_width","","Generate the factors of a CRT modulus that support at…",null,[[],["vec",3]]],[5,"product","","Generate a CRT modulus that support at least n-bit…",null,[[]]],[5,"is_power_of_2","","Raise a u16 to a power mod some value. Returns `true` if…",null,[[]]],[17,"NPRIMES","","Number of primes supported by our library.",null,null],[17,"PRIMES","","Primes used in fancy garbling.",null,null],[8,"RngExt","","Extra Rng functionality, useful for `fancy-garbling`.",null,null],[11,"gen_bool","","Randomly generate a `bool`.",34,[[]]],[11,"gen_u16","","Randomly generate a `u16`.",34,[[]]],[11,"gen_u32","","Randomly generate a `u32`.",34,[[]]],[11,"gen_u64","","Randomly generate a `u64`.",34,[[]]],[11,"gen_usize","","Randomly generate a `usize`.",34,[[]]],[11,"gen_u128","","Randomly generate a `u128`.",34,[[]]],[11,"gen_block","","Randomly generate a `Block`.",34,[[],["block",3]]],[11,"gen_usable_block","","Randomly generate a valid `Block`.",34,[[],["block",3]]],[11,"gen_prime","","Randomly generate a prime (among the set of supported…",34,[[]]],[11,"gen_modulus","","Randomly generate a (supported) modulus.",34,[[]]],[11,"gen_usable_composite_modulus","","Randomly generate a valid composite modulus.",34,[[]]],[11,"gen_usable_factors","","Randomly generate a vector of valid factor",34,[[],["vec",3]]],[11,"digits","fancy_garbling","Get the digits of the wire.",0,[[],["vec",3]]],[11,"from_block","","Unpack the wire represented by a `Block` with modulus `q`.…",0,[[["block",3]]]],[11,"as_block","","Pack the wire into a `Block`.",0,[[],["block",3]]],[11,"zero","","The zero wire with modulus `q`.",0,[[]]],[11,"rand_delta","","Get a random wire label mod `q`, with the first digit set…",0,[[]]],[11,"color","","Get the color digit of the wire.",0,[[]]],[11,"plus","","Add two wires digit-wise, returning a new wire.",0,[[]]],[11,"plus_eq","","Add another wire digit-wise into this one. Assumes that…",0,[[["wire",4]],["wire",4]]],[11,"plus_mov","","Add another wire into this one, consuming it for chained…",0,[[["wire",4]],["wire",4]]],[11,"cmul","","Multiply each digit by a constant `c mod q`, returning a…",0,[[]]],[11,"cmul_eq","","Multiply each digit by a constant `c mod q`.",0,[[],["wire",4]]],[11,"cmul_mov","","Multiply each digit by a constant `c mod q`, consuming it…",0,[[],["wire",4]]],[11,"negate","","Negate all the digits `mod q`, returning a new wire.",0,[[]]],[11,"negate_eq","","Negate all the digits mod q.",0,[[],["wire",4]]],[11,"negate_mov","","Negate all the digits `mod q`, consuming it for chained…",0,[[],["wire",4]]],[11,"minus","","Subtract two wires, returning the result.",0,[[["wire",4]],["wire",4]]],[11,"minus_eq","","Subtract a wire from this one.",0,[[["wire",4]],["wire",4]]],[11,"minus_mov","","Subtract a wire from this one, consuming it for chained…",0,[[["wire",4]],["wire",4]]],[11,"rand","","Get a random wire `mod q`.",0,[[],["wire",4]]],[11,"hash","","Compute the hash of this wire.",0,[[["block",3]],["block",3]]],[11,"hashback","","Compute the hash of this wire, converting the result back…",0,[[["block",3]],["wire",4]]],[8,"BinaryGadgets","","Extension trait for `Fancy` providing gadgets that operate…",null,null],[11,"bin_constant_bundle","","Create a constant bundle using base 2 inputs.",35,[[],[["result",4],["binarybundle",3]]]],[11,"bin_output","","Output a binary bundle and interpret the result as a `u128`.",35,[[["binarybundle",3]],[["option",4],["result",4]]]],[11,"bin_outputs","","Output a slice of binary bundles and interpret the results…",35,[[],[["result",4],["option",4]]]],[11,"bin_xor","","Xor the bits of two bundles together pairwise.",35,[[["binarybundle",3]],[["result",4],["binarybundle",3]]]],[11,"bin_and","","And the bits of two bundles together pairwise.",35,[[["binarybundle",3]],[["result",4],["binarybundle",3]]]],[11,"bin_or","","Or the bits of two bundles together pairwise.",35,[[["binarybundle",3]],[["result",4],["binarybundle",3]]]],[11,"bin_addition","","Binary addition. Returns the result and the carry.",35,[[["binarybundle",3]],["result",4]]],[11,"bin_addition_no_carry","","Binary addition. Avoids creating extra gates for the final…",35,[[["binarybundle",3]],[["result",4],["binarybundle",3]]]],[11,"bin_multiplication_lower_half","","Binary multiplication.",35,[[["binarybundle",3]],[["result",4],["binarybundle",3]]]],[11,"bin_twos_complement","","Compute the twos complement of the input bundle (which…",35,[[["binarybundle",3]],[["result",4],["binarybundle",3]]]],[11,"bin_subtraction","","Subtract two binary bundles. Returns the result and…",35,[[["binarybundle",3]],["result",4]]],[11,"bin_multiplex_constant_bits","","If `x=0` return `c1` as a bundle of constant bits, else…",35,[[],[["result",4],["binarybundle",3]]]],[11,"bin_cmul","","Write the constant in binary and that gives you the shift…",35,[[["binarybundle",3]],[["result",4],["binarybundle",3]]]],[11,"bin_abs","","Compute the absolute value of a binary bundle.",35,[[["binarybundle",3]],[["result",4],["binarybundle",3]]]],[11,"bin_lt","","Returns 1 if `x < y`.",35,[[["binarybundle",3]],["result",4]]],[11,"bin_geq","","Returns 1 if `x >= y`.",35,[[["binarybundle",3]],["result",4]]],[11,"bin_max","","Compute the maximum bundle in `xs`.",35,[[],[["result",4],["binarybundle",3]]]],[11,"bin_demux","","Demux a binary bundle into a unary vector.",35,[[["binarybundle",3]],[["result",4],["vec",3]]]],[8,"BundleGadgets","","Extension trait for Fancy which provides Bundle…",null,null],[11,"constant_bundle","","Creates a bundle of constant wires using moduli `ps`.",36,[[],[["bundle",3],["result",4]]]],[11,"output_bundle","","Output the wires that make up a bundle.",36,[[["bundle",3]],[["result",4],["option",4]]]],[11,"output_bundles","","Output a slice of bundles.",36,[[],[["result",4],["option",4]]]],[11,"add_bundles","","Add two wire bundles pairwise, zipping addition.",36,[[["bundle",3]],[["bundle",3],["result",4]]]],[11,"sub_bundles","","Subtract two wire bundles, residue by residue.",36,[[["bundle",3]],[["bundle",3],["result",4]]]],[11,"mul_bundles","","Multiply each wire in `x` with each wire in `y`, pairwise.",36,[[["bundle",3]],[["bundle",3],["result",4]]]],[11,"mixed_radix_addition","","Mixed radix addition.",36,[[],[["bundle",3],["result",4]]]],[11,"mixed_radix_addition_msb_only","","Mixed radix addition only returning the MSB.",36,[[],["result",4]]],[11,"multiplex","","If b=0 then return x, else return y.",36,[[["bundle",3]],[["bundle",3],["result",4]]]],[11,"mask","","If b=0 then return 0, else return x.",36,[[["bundle",3]],[["bundle",3],["result",4]]]],[11,"shift","","Shift residues, replacing them with zeros in the modulus…",36,[[["bundle",3]],[["bundle",3],["result",4]]]],[11,"eq_bundles","","Compute `x == y`. Returns a wire encoding the result mod 2.",36,[[["bundle",3]],["result",4]]],[8,"CrtGadgets","","Extension trait for `Fancy` providing advanced CRT gadgets…",null,null],[11,"crt_constant_bundle","","Creates a bundle of constant wires for the CRT…",37,[[],[["result",4],["crtbundle",3]]]],[11,"crt_output","","Output a CRT bundle and interpret it mod Q.",37,[[["crtbundle",3]],[["option",4],["result",4]]]],[11,"crt_outputs","","Output a slice of CRT bundles and interpret the outputs…",37,[[],[["result",4],["option",4]]]],[11,"crt_add","","Add two CRT bundles.",37,[[["crtbundle",3]],[["result",4],["crtbundle",3]]]],[11,"crt_sub","","Subtract two CRT bundles.",37,[[["crtbundle",3]],[["result",4],["crtbundle",3]]]],[11,"crt_cmul","","Multiplies each wire in `x` by the corresponding residue…",37,[[["crtbundle",3]],[["result",4],["crtbundle",3]]]],[11,"crt_mul","","Multiply `x` with `y`.",37,[[["crtbundle",3]],[["result",4],["crtbundle",3]]]],[11,"crt_cexp","","Exponentiate `x` by the constant `c`.",37,[[["crtbundle",3]],[["result",4],["crtbundle",3]]]],[11,"crt_rem","","Compute the remainder with respect to modulus `p`.",37,[[["crtbundle",3]],[["result",4],["crtbundle",3]]]],[11,"crt_fractional_mixed_radix","","Helper function for advanced gadgets, returns the MSB of…",37,[[["crtbundle",3]],["result",4]]],[11,"crt_relu","","Compute `max(x,0)`.",37,[[["crtbundle",3],["option",4]],[["result",4],["crtbundle",3]]]],[11,"crt_sign","","Return 0 if `x` is positive and 1 if `x` is negative.",37,[[["crtbundle",3]],["result",4]]],[11,"crt_sgn","","Return `if x >= 0 then 1 else -1`, where `-1` is…",37,[[["crtbundle",3],["option",4]],[["result",4],["crtbundle",3]]]],[11,"crt_lt","","Returns 1 if `x < y`.",37,[[["crtbundle",3]],["result",4]]],[11,"crt_geq","","Returns 1 if `x >= y`.",37,[[["crtbundle",3]],["result",4]]],[11,"crt_max","","Compute the maximum bundle in `xs`.",37,[[],[["result",4],["crtbundle",3]]]],[8,"FancyInput","","Convenience functions for encoding input to Fancy objects.",null,null],[16,"Item","","The type that this Fancy object operates over.",38,null],[16,"Error","","The type of error that this Fancy object emits.",38,null],[16,"PartyId","","The type representing a party in the protocol.",38,null],[10,"encode_many","","Encode many values where the actual input is known.",38,[[],[["vec",3],["result",4]]]],[10,"receive_many","","Receive many values where the input is not known. The…",38,[[],[["vec",3],["result",4]]]],[11,"encode","","Encode a single value.",38,[[],["result",4]]],[11,"receive","","Receive a single value form party `from`.",38,[[],["result",4]]],[11,"encode_bundle","","Encode a bundle.",38,[[],[["bundle",3],["result",4]]]],[11,"receive_bundle","","Receive a bundle of values from party `from`.",38,[[],[["bundle",3],["result",4]]]],[11,"encode_bundles","","Encode many input bundles.",38,[[],[["vec",3],["result",4]]]],[11,"receive_many_bundles","","Receive many input bundles from party `from`.",38,[[],[["vec",3],["result",4]]]],[11,"crt_encode","","Encode a CRT input bundle.",38,[[],[["crtbundle",3],["result",4]]]],[11,"crt_receive","","Receive an CRT input bundle from party `from`.",38,[[],[["crtbundle",3],["result",4]]]],[11,"crt_encode_many","","Encode many CRT input bundles.",38,[[],[["result",4],["vec",3]]]],[11,"crt_receive_many","","Receive many CRT input bundles from party `from`.",38,[[],[["result",4],["vec",3]]]],[11,"bin_encode","","Encode a binary input bundle.",38,[[],[["binarybundle",3],["result",4]]]],[11,"bin_receive","","Receive an binary input bundle from party `from`.",38,[[],[["binarybundle",3],["result",4]]]],[11,"bin_encode_many","","Encode many binary input bundles.",38,[[],[["result",4],["vec",3]]]],[11,"bin_receive_many","","Receive many binary input bundles from party `from`.",38,[[],[["result",4],["vec",3]]]],[8,"FancyReveal","","Trait to describe Fancy objects which can reveal outputs…",null,null],[10,"reveal","","Reveal the contents of `x` to all parties.",39,[[],["result",4]]],[11,"reveal_many","","Reveal a slice of items to all parties.",39,[[],[["result",4],["vec",3]]]],[11,"reveal_bundle","","Reveal a bundle to all parties.",39,[[["bundle",3]],[["result",4],["vec",3]]]],[11,"reveal_many_bundles","","Reveal many bundles to all parties.",39,[[],[["vec",3],["result",4]]]],[11,"crt_reveal","","Reveal a CRT bundle to all parties.",39,[[["crtbundle",3]],["result",4]]],[11,"crt_reveal_many","","Reveal many CRT bundles to all parties.",39,[[],[["vec",3],["result",4]]]],[11,"bin_reveal","","Reveal a binary bundle to all parties.",39,[[["binarybundle",3]],["result",4]]],[11,"bin_reveal_many","","Reveal many binary bundles to all parties.",39,[[],[["vec",3],["result",4]]]],[8,"HasModulus","","An object that has some modulus. Basic object of `Fancy`…",null,null],[10,"modulus","","The modulus of the wire.",40,[[]]],[8,"Fancy","","DSL for the basic computations supported by…",null,null],[16,"Item","","The underlying wire datatype created by an object…",41,null],[16,"Error","","Errors which may be thrown by the users of Fancy.",41,null],[10,"constant","","Create a constant `x` with modulus `q`.",41,[[],["result",4]]],[10,"add","","Add `x` and `y`.",41,[[],["result",4]]],[10,"sub","","Subtract `x` and `y`.",41,[[],["result",4]]],[10,"cmul","","Multiply `x` times the constant `c`.",41,[[],["result",4]]],[10,"mul","","Multiply `x` and `y`.",41,[[],["result",4]]],[10,"proj","","Project `x` according to the truth table `tt`. Resulting…",41,[[["option",4],["vec",3]],["result",4]]],[10,"output","","Process this wire as output. Some `Fancy` implementors…",41,[[],[["result",4],["option",4]]]],[11,"add_many","","Sum up a slice of wires.",41,[[],["result",4]]],[11,"xor","","Xor is just addition, with the requirement that `x` and…",41,[[],["result",4]]],[11,"negate","","Negate by xoring `x` with `1`.",41,[[],["result",4]]],[11,"and","","And is just multiplication, with the requirement that `x`…",41,[[],["result",4]]],[11,"or","","Or uses Demorgan\'s Rule implemented with multiplication…",41,[[],["result",4]]],[11,"and_many","","Returns 1 if all wires equal 1.",41,[[],["result",4]]],[11,"or_many","","Returns 1 if any wire equals 1.",41,[[],["result",4]]],[11,"mod_change","","Change the modulus of `x` to `to_modulus` using a…",41,[[],["result",4]]],[11,"adder","","Binary adder. Returns the result and the carry.",41,[[["option",4]],["result",4]]],[11,"mux","","If `b = 0` returns `x` else `y`.",41,[[],["result",4]]],[11,"mux_constant_bits","","If `x = 0` returns the constant `b1` else return `b2`.…",41,[[],["result",4]]],[11,"outputs","","Output a slice of wires.",41,[[],[["result",4],["option",4]]]],[11,"from","","",19,[[]]],[11,"into","","",19,[[]]],[11,"to_owned","","",19,[[]]],[11,"clone_into","","",19,[[]]],[11,"try_from","","",19,[[],["result",4]]],[11,"try_into","","",19,[[],["result",4]]],[11,"borrow","","",19,[[]]],[11,"borrow_mut","","",19,[[]]],[11,"type_id","","",19,[[],["typeid",3]]],[11,"from_cast","","",19,[[]]],[11,"cast","","",19,[[]]],[11,"from_bits","","",19,[[]]],[11,"into_bits","","",19,[[]]],[11,"vzip","","",19,[[]]],[11,"from","","",20,[[]]],[11,"into","","",20,[[]]],[11,"to_owned","","",20,[[]]],[11,"clone_into","","",20,[[]]],[11,"try_from","","",20,[[],["result",4]]],[11,"try_into","","",20,[[],["result",4]]],[11,"borrow","","",20,[[]]],[11,"borrow_mut","","",20,[[]]],[11,"type_id","","",20,[[],["typeid",3]]],[11,"from_cast","","",20,[[]]],[11,"cast","","",20,[[]]],[11,"from_bits","","",20,[[]]],[11,"into_bits","","",20,[[]]],[11,"vzip","","",20,[[]]],[11,"from","","",21,[[]]],[11,"into","","",21,[[]]],[11,"to_owned","","",21,[[]]],[11,"clone_into","","",21,[[]]],[11,"try_from","","",21,[[],["result",4]]],[11,"try_into","","",21,[[],["result",4]]],[11,"borrow","","",21,[[]]],[11,"borrow_mut","","",21,[[]]],[11,"type_id","","",21,[[],["typeid",3]]],[11,"from_cast","","",21,[[]]],[11,"cast","","",21,[[]]],[11,"from_bits","","",21,[[]]],[11,"into_bits","","",21,[[]]],[11,"vzip","","",21,[[]]],[11,"from","","",22,[[]]],[11,"into","","",22,[[]]],[11,"try_from","","",22,[[],["result",4]]],[11,"try_into","","",22,[[],["result",4]]],[11,"borrow","","",22,[[]]],[11,"borrow_mut","","",22,[[]]],[11,"type_id","","",22,[[],["typeid",3]]],[11,"from_cast","","",22,[[]]],[11,"cast","","",22,[[]]],[11,"from_bits","","",22,[[]]],[11,"into_bits","","",22,[[]]],[11,"vzip","","",22,[[]]],[11,"from","","",23,[[]]],[11,"into","","",23,[[]]],[11,"try_from","","",23,[[],["result",4]]],[11,"try_into","","",23,[[],["result",4]]],[11,"borrow","","",23,[[]]],[11,"borrow_mut","","",23,[[]]],[11,"type_id","","",23,[[],["typeid",3]]],[11,"from_cast","","",23,[[]]],[11,"cast","","",23,[[]]],[11,"from_bits","","",23,[[]]],[11,"into_bits","","",23,[[]]],[11,"vzip","","",23,[[]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from_cast","","",0,[[]]],[11,"cast","","",0,[[]]],[11,"from_bits","","",0,[[]]],[11,"into_bits","","",0,[[]]],[11,"vzip","","",0,[[]]],[11,"from","fancy_garbling::circuit","",42,[[]]],[11,"into","","",42,[[]]],[11,"to_owned","","",42,[[]]],[11,"clone_into","","",42,[[]]],[11,"to_string","","",42,[[],["string",3]]],[11,"try_from","","",42,[[],["result",4]]],[11,"try_into","","",42,[[],["result",4]]],[11,"borrow","","",42,[[]]],[11,"borrow_mut","","",42,[[]]],[11,"type_id","","",42,[[],["typeid",3]]],[11,"from_cast","","",42,[[]]],[11,"cast","","",42,[[]]],[11,"from_bits","","",42,[[]]],[11,"into_bits","","",42,[[]]],[11,"vzip","","",42,[[]]],[11,"from","","",4,[[]]],[11,"into","","",4,[[]]],[11,"to_owned","","",4,[[]]],[11,"clone_into","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from_cast","","",4,[[]]],[11,"cast","","",4,[[]]],[11,"from_bits","","",4,[[]]],[11,"into_bits","","",4,[[]]],[11,"vzip","","",4,[[]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from_cast","","",5,[[]]],[11,"cast","","",5,[[]]],[11,"from_bits","","",5,[[]]],[11,"into_bits","","",5,[[]]],[11,"vzip","","",5,[[]]],[11,"from","fancy_garbling::classic","",6,[[]]],[11,"into","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from_cast","","",6,[[]]],[11,"cast","","",6,[[]]],[11,"from_bits","","",6,[[]]],[11,"into_bits","","",6,[[]]],[11,"vzip","","",6,[[]]],[11,"from","","",7,[[]]],[11,"into","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from_cast","","",7,[[]]],[11,"cast","","",7,[[]]],[11,"from_bits","","",7,[[]]],[11,"into_bits","","",7,[[]]],[11,"vzip","","",7,[[]]],[11,"from","fancy_garbling::dummy","",9,[[]]],[11,"into","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"try_into","","",9,[[],["result",4]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"from_cast","","",9,[[]]],[11,"cast","","",9,[[]]],[11,"from_bits","","",9,[[]]],[11,"into_bits","","",9,[[]]],[11,"vzip","","",9,[[]]],[11,"from","","",8,[[]]],[11,"into","","",8,[[]]],[11,"to_owned","","",8,[[]]],[11,"clone_into","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"from_cast","","",8,[[]]],[11,"cast","","",8,[[]]],[11,"from_bits","","",8,[[]]],[11,"into_bits","","",8,[[]]],[11,"vzip","","",8,[[]]],[11,"from","fancy_garbling::errors","",10,[[]]],[11,"into","","",10,[[]]],[11,"to_string","","",10,[[],["string",3]]],[11,"try_from","","",10,[[],["result",4]]],[11,"try_into","","",10,[[],["result",4]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"from_cast","","",10,[[]]],[11,"cast","","",10,[[]]],[11,"from_bits","","",10,[[]]],[11,"into_bits","","",10,[[]]],[11,"vzip","","",10,[[]]],[11,"from","","",13,[[]]],[11,"into","","",13,[[]]],[11,"to_string","","",13,[[],["string",3]]],[11,"try_from","","",13,[[],["result",4]]],[11,"try_into","","",13,[[],["result",4]]],[11,"borrow","","",13,[[]]],[11,"borrow_mut","","",13,[[]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"from_cast","","",13,[[]]],[11,"cast","","",13,[[]]],[11,"from_bits","","",13,[[]]],[11,"into_bits","","",13,[[]]],[11,"vzip","","",13,[[]]],[11,"from","","",14,[[]]],[11,"into","","",14,[[]]],[11,"to_string","","",14,[[],["string",3]]],[11,"try_from","","",14,[[],["result",4]]],[11,"try_into","","",14,[[],["result",4]]],[11,"borrow","","",14,[[]]],[11,"borrow_mut","","",14,[[]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"from_cast","","",14,[[]]],[11,"cast","","",14,[[]]],[11,"from_bits","","",14,[[]]],[11,"into_bits","","",14,[[]]],[11,"vzip","","",14,[[]]],[11,"from","","",15,[[]]],[11,"into","","",15,[[]]],[11,"to_string","","",15,[[],["string",3]]],[11,"try_from","","",15,[[],["result",4]]],[11,"try_into","","",15,[[],["result",4]]],[11,"borrow","","",15,[[]]],[11,"borrow_mut","","",15,[[]]],[11,"type_id","","",15,[[],["typeid",3]]],[11,"from_cast","","",15,[[]]],[11,"cast","","",15,[[]]],[11,"from_bits","","",15,[[]]],[11,"into_bits","","",15,[[]]],[11,"vzip","","",15,[[]]],[11,"from","","",16,[[]]],[11,"into","","",16,[[]]],[11,"to_string","","",16,[[],["string",3]]],[11,"try_from","","",16,[[],["result",4]]],[11,"try_into","","",16,[[],["result",4]]],[11,"borrow","","",16,[[]]],[11,"borrow_mut","","",16,[[]]],[11,"type_id","","",16,[[],["typeid",3]]],[11,"from_cast","","",16,[[]]],[11,"cast","","",16,[[]]],[11,"from_bits","","",16,[[]]],[11,"into_bits","","",16,[[]]],[11,"vzip","","",16,[[]]],[11,"from","","",17,[[]]],[11,"into","","",17,[[]]],[11,"to_string","","",17,[[],["string",3]]],[11,"try_from","","",17,[[],["result",4]]],[11,"try_into","","",17,[[],["result",4]]],[11,"borrow","","",17,[[]]],[11,"borrow_mut","","",17,[[]]],[11,"type_id","","",17,[[],["typeid",3]]],[11,"from_cast","","",17,[[]]],[11,"cast","","",17,[[]]],[11,"from_bits","","",17,[[]]],[11,"into_bits","","",17,[[]]],[11,"vzip","","",17,[[]]],[11,"from","","",18,[[]]],[11,"into","","",18,[[]]],[11,"to_string","","",18,[[],["string",3]]],[11,"try_from","","",18,[[],["result",4]]],[11,"try_into","","",18,[[],["result",4]]],[11,"borrow","","",18,[[]]],[11,"borrow_mut","","",18,[[]]],[11,"type_id","","",18,[[],["typeid",3]]],[11,"from_cast","","",18,[[]]],[11,"cast","","",18,[[]]],[11,"from_bits","","",18,[[]]],[11,"into_bits","","",18,[[]]],[11,"vzip","","",18,[[]]],[11,"from","fancy_garbling::informer","",24,[[]]],[11,"into","","",24,[[]]],[11,"try_from","","",24,[[],["result",4]]],[11,"try_into","","",24,[[],["result",4]]],[11,"borrow","","",24,[[]]],[11,"borrow_mut","","",24,[[]]],[11,"type_id","","",24,[[],["typeid",3]]],[11,"from_cast","","",24,[[]]],[11,"cast","","",24,[[]]],[11,"from_bits","","",24,[[]]],[11,"into_bits","","",24,[[]]],[11,"vzip","","",24,[[]]],[11,"from","","",25,[[]]],[11,"into","","",25,[[]]],[11,"to_owned","","",25,[[]]],[11,"clone_into","","",25,[[]]],[11,"to_string","","",25,[[],["string",3]]],[11,"try_from","","",25,[[],["result",4]]],[11,"try_into","","",25,[[],["result",4]]],[11,"borrow","","",25,[[]]],[11,"borrow_mut","","",25,[[]]],[11,"type_id","","",25,[[],["typeid",3]]],[11,"from_cast","","",25,[[]]],[11,"cast","","",25,[[]]],[11,"from_bits","","",25,[[]]],[11,"into_bits","","",25,[[]]],[11,"vzip","","",25,[[]]],[11,"from","fancy_garbling::twopac::semihonest","",27,[[]]],[11,"into","","",27,[[]]],[11,"try_from","","",27,[[],["result",4]]],[11,"try_into","","",27,[[],["result",4]]],[11,"borrow","","",27,[[]]],[11,"borrow_mut","","",27,[[]]],[11,"type_id","","",27,[[],["typeid",3]]],[11,"from_cast","","",27,[[]]],[11,"cast","","",27,[[]]],[11,"from_bits","","",27,[[]]],[11,"into_bits","","",27,[[]]],[11,"vzip","","",27,[[]]],[11,"from","","",28,[[]]],[11,"into","","",28,[[]]],[11,"try_from","","",28,[[],["result",4]]],[11,"try_into","","",28,[[],["result",4]]],[11,"borrow","","",28,[[]]],[11,"borrow_mut","","",28,[[]]],[11,"type_id","","",28,[[],["typeid",3]]],[11,"from_cast","","",28,[[]]],[11,"cast","","",28,[[]]],[11,"from_bits","","",28,[[]]],[11,"into_bits","","",28,[[]]],[11,"vzip","","",28,[[]]],[11,"from","","",26,[[]]],[11,"into","","",26,[[]]],[11,"to_owned","","",26,[[]]],[11,"clone_into","","",26,[[]]],[11,"try_from","","",26,[[],["result",4]]],[11,"try_into","","",26,[[],["result",4]]],[11,"borrow","","",26,[[]]],[11,"borrow_mut","","",26,[[]]],[11,"type_id","","",26,[[],["typeid",3]]],[11,"from_cast","","",26,[[]]],[11,"cast","","",26,[[]]],[11,"from_bits","","",26,[[]]],[11,"into_bits","","",26,[[]]],[11,"vzip","","",26,[[]]],[11,"from","fancy_garbling::threepac::malicious","",29,[[]]],[11,"into","","",29,[[]]],[11,"to_owned","","",29,[[]]],[11,"clone_into","","",29,[[]]],[11,"try_from","","",29,[[],["result",4]]],[11,"try_into","","",29,[[],["result",4]]],[11,"borrow","","",29,[[]]],[11,"borrow_mut","","",29,[[]]],[11,"type_id","","",29,[[],["typeid",3]]],[11,"from_cast","","",29,[[]]],[11,"cast","","",29,[[]]],[11,"from_bits","","",29,[[]]],[11,"into_bits","","",29,[[]]],[11,"vzip","","",29,[[]]],[11,"from","fancy_garbling::threepac::malicious::evaluator","",31,[[]]],[11,"into","","",31,[[]]],[11,"try_from","","",31,[[],["result",4]]],[11,"try_into","","",31,[[],["result",4]]],[11,"borrow","","",31,[[]]],[11,"borrow_mut","","",31,[[]]],[11,"type_id","","",31,[[],["typeid",3]]],[11,"from_cast","","",31,[[]]],[11,"cast","","",31,[[]]],[11,"from_bits","","",31,[[]]],[11,"into_bits","","",31,[[]]],[11,"vzip","","",31,[[]]],[11,"from","","",30,[[]]],[11,"into","","",30,[[]]],[11,"to_string","","",30,[[],["string",3]]],[11,"try_from","","",30,[[],["result",4]]],[11,"try_into","","",30,[[],["result",4]]],[11,"borrow","","",30,[[]]],[11,"borrow_mut","","",30,[[]]],[11,"type_id","","",30,[[],["typeid",3]]],[11,"from_cast","","",30,[[]]],[11,"cast","","",30,[[]]],[11,"from_bits","","",30,[[]]],[11,"into_bits","","",30,[[]]],[11,"vzip","","",30,[[]]],[11,"from","fancy_garbling::threepac::malicious::garbler","",33,[[]]],[11,"into","","",33,[[]]],[11,"try_from","","",33,[[],["result",4]]],[11,"try_into","","",33,[[],["result",4]]],[11,"borrow","","",33,[[]]],[11,"borrow_mut","","",33,[[]]],[11,"type_id","","",33,[[],["typeid",3]]],[11,"from_cast","","",33,[[]]],[11,"cast","","",33,[[]]],[11,"from_bits","","",33,[[]]],[11,"into_bits","","",33,[[]]],[11,"vzip","","",33,[[]]],[11,"from","","",32,[[]]],[11,"into","","",32,[[]]],[11,"to_string","","",32,[[],["string",3]]],[11,"try_from","","",32,[[],["result",4]]],[11,"try_into","","",32,[[],["result",4]]],[11,"borrow","","",32,[[]]],[11,"borrow_mut","","",32,[[]]],[11,"type_id","","",32,[[],["typeid",3]]],[11,"from_cast","","",32,[[]]],[11,"cast","","",32,[[]]],[11,"from_bits","","",32,[[]]],[11,"into_bits","","",32,[[]]],[11,"vzip","","",32,[[]]],[11,"encode","fancy_garbling::dummy","Encode a single dummy value.",9,[[],[["dummyerror",4],["dummyval",3],["result",4]]]],[11,"encode_many","","Encode a slice of inputs and a slice of moduli as DummyVals.",9,[[],[["vec",3],["dummyerror",4],["result",4]]]],[11,"receive_many","","",9,[[],[["vec",3],["dummyerror",4],["result",4]]]],[11,"receive_many","fancy_garbling::informer","",24,[[],[["vec",3],["result",4]]]],[11,"encode_many","","",24,[[],[["vec",3],["result",4]]]],[11,"receive","fancy_garbling::twopac::semihonest","Receive a garbler input wire.",27,[[["partyid",4]],[["result",4],["wire",4],["twopacerror",4]]]],[11,"receive_many","","Receive garbler input wires.",27,[[["partyid",4]],[["vec",3],["result",4],["twopacerror",4]]]],[11,"encode_many","","Perform OT and obtain wires for the evaluator\'s inputs.",27,[[],[["vec",3],["result",4],["twopacerror",4]]]],[11,"encode","","",28,[[],[["result",4],["wire",4],["twopacerror",4]]]],[11,"encode_many","","",28,[[],[["vec",3],["result",4],["twopacerror",4]]]],[11,"receive_many","","",28,[[["partyid",4]],[["vec",3],["result",4],["twopacerror",4]]]],[11,"receive_many","fancy_garbling::threepac::malicious::evaluator","Receive garbler input wires.",31,[[["partyid",4]],[["result",4],["vec",3],["error",4]]]],[11,"encode_many","","Obtain wires for the evaluator\'s inputs.",31,[[],[["result",4],["vec",3],["error",4]]]],[11,"encode_many","fancy_garbling::threepac::malicious::garbler","",33,[[],[["result",4],["vec",3],["error",4]]]],[11,"receive_many","","",33,[[["partyid",4]],[["result",4],["vec",3],["error",4]]]],[11,"reveal","fancy_garbling::dummy","",9,[[["dummyval",3]],[["result",4],["dummyerror",4]]]],[11,"reveal","fancy_garbling","",22,[[["wire",4]],[["evaluatorerror",4],["result",4]]]],[11,"reveal","","",23,[[["wire",4]],[["garblererror",4],["result",4]]]],[11,"reveal","fancy_garbling::informer","",24,[[],["result",4]]],[11,"reveal","fancy_garbling::twopac::semihonest","",27,[[],["result",4]]],[11,"reveal","","",28,[[],["result",4]]],[11,"reveal","fancy_garbling::threepac::malicious::evaluator","",31,[[],["result",4]]],[11,"reveal_many","","",31,[[],[["result",4],["vec",3]]]],[11,"reveal","fancy_garbling::threepac::malicious::garbler","",33,[[],["result",4]]],[11,"reveal_many","","",33,[[],[["result",4],["vec",3]]]],[11,"modulus","fancy_garbling::circuit","",42,[[]]],[11,"modulus","fancy_garbling::dummy","",8,[[]]],[11,"modulus","fancy_garbling","",0,[[]]],[11,"constant","fancy_garbling::circuit","",5,[[],[["result",4],["circuitref",3]]]],[11,"add","","",5,[[["circuitref",3]],[["result",4],["circuitref",3]]]],[11,"sub","","",5,[[["circuitref",3]],[["result",4],["circuitref",3]]]],[11,"cmul","","",5,[[["circuitref",3]],[["result",4],["circuitref",3]]]],[11,"proj","","",5,[[["option",4],["circuitref",3],["vec",3]],[["result",4],["circuitref",3]]]],[11,"mul","","",5,[[["circuitref",3]],[["result",4],["circuitref",3]]]],[11,"output","","",5,[[["circuitref",3]],[["result",4],["option",4]]]],[11,"constant","fancy_garbling::dummy","",9,[[],[["result",4],["dummyval",3]]]],[11,"add","","",9,[[["dummyval",3]],[["result",4],["dummyval",3]]]],[11,"sub","","",9,[[["dummyval",3]],[["result",4],["dummyval",3]]]],[11,"cmul","","",9,[[["dummyval",3]],[["result",4],["dummyval",3]]]],[11,"mul","","",9,[[["dummyval",3]],[["result",4],["dummyval",3]]]],[11,"proj","","",9,[[["option",4],["vec",3],["dummyval",3]],[["result",4],["dummyval",3]]]],[11,"output","","",9,[[["dummyval",3]],[["result",4],["option",4]]]],[11,"constant","fancy_garbling","",22,[[],[["evaluatorerror",4],["result",4],["wire",4]]]],[11,"add","","",22,[[["wire",4]],[["evaluatorerror",4],["result",4],["wire",4]]]],[11,"sub","","",22,[[["wire",4]],[["evaluatorerror",4],["result",4],["wire",4]]]],[11,"cmul","","",22,[[["wire",4]],[["evaluatorerror",4],["result",4],["wire",4]]]],[11,"mul","","",22,[[["wire",4]],[["evaluatorerror",4],["result",4],["wire",4]]]],[11,"proj","","",22,[[["option",4],["vec",3],["wire",4]],[["evaluatorerror",4],["result",4],["wire",4]]]],[11,"output","","",22,[[["wire",4]],[["evaluatorerror",4],["option",4],["result",4]]]],[11,"constant","","",23,[[],[["garblererror",4],["wire",4],["result",4]]]],[11,"add","","",23,[[["wire",4]],[["garblererror",4],["wire",4],["result",4]]]],[11,"sub","","",23,[[["wire",4]],[["garblererror",4],["wire",4],["result",4]]]],[11,"cmul","","",23,[[["wire",4]],[["garblererror",4],["wire",4],["result",4]]]],[11,"mul","","",23,[[["wire",4]],[["garblererror",4],["wire",4],["result",4]]]],[11,"proj","","",23,[[["option",4],["vec",3],["wire",4]],[["garblererror",4],["wire",4],["result",4]]]],[11,"output","","",23,[[["wire",4]],[["result",4],["option",4],["garblererror",4]]]],[11,"constant","fancy_garbling::informer","",24,[[],["result",4]]],[11,"add","","",24,[[],["result",4]]],[11,"sub","","",24,[[],["result",4]]],[11,"cmul","","",24,[[],["result",4]]],[11,"mul","","",24,[[],["result",4]]],[11,"proj","","",24,[[["option",4],["vec",3]],["result",4]]],[11,"output","","",24,[[],[["result",4],["option",4]]]],[11,"constant","fancy_garbling::twopac::semihonest","",27,[[],["result",4]]],[11,"add","","",27,[[["wire",4]],["result",4]]],[11,"sub","","",27,[[["wire",4]],["result",4]]],[11,"cmul","","",27,[[["wire",4]],["result",4]]],[11,"mul","","",27,[[["wire",4]],["result",4]]],[11,"proj","","",27,[[["option",4],["vec",3],["wire",4]],["result",4]]],[11,"output","","",27,[[["wire",4]],[["result",4],["option",4]]]],[11,"constant","","",28,[[],["result",4]]],[11,"add","","",28,[[["wire",4]],["result",4]]],[11,"sub","","",28,[[["wire",4]],["result",4]]],[11,"cmul","","",28,[[["wire",4]],["result",4]]],[11,"mul","","",28,[[["wire",4]],["result",4]]],[11,"proj","","",28,[[["option",4],["vec",3],["wire",4]],["result",4]]],[11,"output","","",28,[[],[["result",4],["option",4]]]],[11,"constant","fancy_garbling::threepac::malicious::evaluator","",31,[[],["result",4]]],[11,"add","","",31,[[["wire",4]],["result",4]]],[11,"sub","","",31,[[["wire",4]],["result",4]]],[11,"cmul","","",31,[[["wire",4]],["result",4]]],[11,"mul","","",31,[[["wire",4]],["result",4]]],[11,"proj","","",31,[[["option",4],["vec",3],["wire",4]],["result",4]]],[11,"output","","",31,[[["wire",4]],[["result",4],["option",4]]]],[11,"constant","fancy_garbling::threepac::malicious::garbler","",33,[[],["result",4]]],[11,"add","","",33,[[["wire",4]],["result",4]]],[11,"sub","","",33,[[["wire",4]],["result",4]]],[11,"cmul","","",33,[[["wire",4]],["result",4]]],[11,"mul","","",33,[[["wire",4]],["result",4]]],[11,"proj","","",33,[[["option",4],["vec",3],["wire",4]],["result",4]]],[11,"output","","",33,[[],[["result",4],["option",4]]]],[11,"from","fancy_garbling::errors","",13,[[["fancyerror",4]],["dummyerror",4]]],[11,"from","","",14,[[["fancyerror",4]]]],[11,"from","","",14,[[["error",3]]]],[11,"from","","",15,[[["fancyerror",4]]]],[11,"from","","",15,[[["error",3]]]],[11,"from","","",16,[[["fancyerror",4]]]],[11,"from","","",17,[[["error",3]],["circuitparsererror",4]]],[11,"from","","",17,[[["error",4]],["circuitparsererror",4]]],[11,"from","","",17,[[["parseinterror",3]],["circuitparsererror",4]]],[11,"from","","",18,[[["error",4]],["twopacerror",4]]],[11,"from","","",18,[[["error",3]],["twopacerror",4]]],[11,"from","","",18,[[["evaluatorerror",4]],["twopacerror",4]]],[11,"from","","",18,[[["garblererror",4]],["twopacerror",4]]],[11,"from","","",18,[[["fancyerror",4]],["twopacerror",4]]],[11,"from","fancy_garbling","",19,[[["bundle",3]],["binarybundle",3]]],[11,"from","","",21,[[["bundle",3]],["crtbundle",3]]],[11,"from","fancy_garbling::threepac::malicious::evaluator","",30,[[["error",3]],["error",4]]],[11,"from","","",30,[[["evaluatorerror",4]],["error",4]]],[11,"from","","",30,[[["fancyerror",4]],["error",4]]],[11,"from","fancy_garbling::threepac::malicious::garbler","",32,[[["error",3]],["error",4]]],[11,"from","","",32,[[["garblererror",4]],["error",4]]],[11,"from","","",32,[[["fancyerror",4]],["error",4]]],[11,"clone","fancy_garbling::circuit","",42,[[],["circuitref",3]]],[11,"clone","","",4,[[],["circuit",3]]],[11,"clone","fancy_garbling::dummy","",8,[[],["dummyval",3]]],[11,"clone","fancy_garbling","",19,[[],["binarybundle",3]]],[11,"clone","","",20,[[],["bundle",3]]],[11,"clone","","",21,[[],["crtbundle",3]]],[11,"clone","fancy_garbling::informer","",25,[[],["informerstats",3]]],[11,"clone","fancy_garbling::twopac::semihonest","",26,[[],["partyid",4]]],[11,"clone","fancy_garbling::threepac::malicious","",29,[[],["partyid",4]]],[11,"clone","fancy_garbling","",0,[[],["wire",4]]],[11,"default","","",0,[[]]],[11,"cmp","fancy_garbling::twopac::semihonest","",26,[[["partyid",4]],["ordering",4]]],[11,"cmp","fancy_garbling::threepac::malicious","",29,[[["partyid",4]],["ordering",4]]],[11,"eq","fancy_garbling::circuit","",42,[[["circuitref",3]]]],[11,"ne","","",42,[[["circuitref",3]]]],[11,"eq","","",4,[[["circuit",3]]]],[11,"ne","","",4,[[["circuit",3]]]],[11,"eq","fancy_garbling::twopac::semihonest","",26,[[["partyid",4]]]],[11,"eq","fancy_garbling::threepac::malicious","",29,[[["partyid",4]]]],[11,"eq","fancy_garbling","",0,[[["wire",4]]]],[11,"ne","","",0,[[["wire",4]]]],[11,"partial_cmp","fancy_garbling::twopac::semihonest","",26,[[["partyid",4]],[["option",4],["ordering",4]]]],[11,"partial_cmp","fancy_garbling::threepac::malicious","",29,[[["partyid",4]],[["option",4],["ordering",4]]]],[11,"deref","fancy_garbling","",19,[[],["bundle",3]]],[11,"deref","","",21,[[],["bundle",3]]],[11,"deref","fancy_garbling::twopac::semihonest","",28,[[]]],[11,"deref_mut","","",28,[[],["gb",3]]],[11,"fmt","fancy_garbling::circuit","",42,[[["formatter",3]],["result",6]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"fmt","fancy_garbling::classic","",6,[[["formatter",3]],["result",6]]],[11,"fmt","","",7,[[["formatter",3]],["result",6]]],[11,"fmt","fancy_garbling::dummy","",8,[[["formatter",3]],["result",6]]],[11,"fmt","fancy_garbling::errors","",10,[[["formatter",3]],["result",6]]],[11,"fmt","","",13,[[["formatter",3]],["result",6]]],[11,"fmt","","",14,[[["formatter",3]],["result",6]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"fmt","","",16,[[["formatter",3]],["result",6]]],[11,"fmt","","",17,[[["formatter",3]],["result",6]]],[11,"fmt","","",18,[[["formatter",3]],["result",6]]],[11,"fmt","fancy_garbling::informer","",25,[[["formatter",3]],["result",6]]],[11,"fmt","fancy_garbling::twopac::semihonest","",26,[[["formatter",3]],["result",6]]],[11,"fmt","fancy_garbling::threepac::malicious::evaluator","",30,[[["formatter",3]],["result",6]]],[11,"fmt","fancy_garbling::threepac::malicious::garbler","",32,[[["formatter",3]],["result",6]]],[11,"fmt","fancy_garbling::threepac::malicious","",29,[[["formatter",3]],["result",6]]],[11,"fmt","fancy_garbling","",0,[[["formatter",3]],["result",6]]],[11,"fmt","fancy_garbling::circuit","",42,[[["formatter",3]],["result",6]]],[11,"fmt","fancy_garbling::errors","",10,[[["formatter",3]],["result",6]]],[11,"fmt","","",13,[[["formatter",3]],["result",6]]],[11,"fmt","","",14,[[["formatter",3]],["result",6]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"fmt","","",16,[[["formatter",3]],["result",6]]],[11,"fmt","","",17,[[["formatter",3]],["result",6]]],[11,"fmt","","",18,[[["formatter",3]],["result",6]]],[11,"fmt","fancy_garbling::informer","Print information about the fancy computation.",25,[[["formatter",3]],["result",6]]],[11,"fmt","fancy_garbling::threepac::malicious::evaluator","",30,[[["formatter",3]],["result",6]]],[11,"fmt","fancy_garbling::threepac::malicious::garbler","",32,[[["formatter",3]],["result",6]]],[11,"index","fancy_garbling","",20,[[]]],[11,"deserialize","fancy_garbling::circuit","",42,[[],["result",4]]],[11,"deserialize","","",4,[[],["result",4]]],[11,"deserialize","fancy_garbling::classic","",6,[[],["result",4]]],[11,"deserialize","","",7,[[],["result",4]]],[11,"deserialize","fancy_garbling","",0,[[],["result",4]]],[11,"serialize","fancy_garbling::circuit","",42,[[],["result",4]]],[11,"serialize","","",4,[[],["result",4]]],[11,"serialize","fancy_garbling::classic","",6,[[],["result",4]]],[11,"serialize","","",7,[[],["result",4]]],[11,"serialize","fancy_garbling","",0,[[],["result",4]]],[11,"bin_constant_bundle","","Create a constant bundle using base 2 inputs.",35,[[],[["result",4],["binarybundle",3]]]],[11,"bin_output","","Output a binary bundle and interpret the result as a `u128`.",35,[[["binarybundle",3]],[["option",4],["result",4]]]],[11,"bin_outputs","","Output a slice of binary bundles and interpret the results…",35,[[],[["result",4],["option",4]]]],[11,"bin_xor","","Xor the bits of two bundles together pairwise.",35,[[["binarybundle",3]],[["result",4],["binarybundle",3]]]],[11,"bin_and","","And the bits of two bundles together pairwise.",35,[[["binarybundle",3]],[["result",4],["binarybundle",3]]]],[11,"bin_or","","Or the bits of two bundles together pairwise.",35,[[["binarybundle",3]],[["result",4],["binarybundle",3]]]],[11,"bin_addition","","Binary addition. Returns the result and the carry.",35,[[["binarybundle",3]],["result",4]]],[11,"bin_addition_no_carry","","Binary addition. Avoids creating extra gates for the final…",35,[[["binarybundle",3]],[["result",4],["binarybundle",3]]]],[11,"bin_multiplication_lower_half","","Binary multiplication.",35,[[["binarybundle",3]],[["result",4],["binarybundle",3]]]],[11,"bin_twos_complement","","Compute the twos complement of the input bundle (which…",35,[[["binarybundle",3]],[["result",4],["binarybundle",3]]]],[11,"bin_subtraction","","Subtract two binary bundles. Returns the result and…",35,[[["binarybundle",3]],["result",4]]],[11,"bin_multiplex_constant_bits","","If `x=0` return `c1` as a bundle of constant bits, else…",35,[[],[["result",4],["binarybundle",3]]]],[11,"bin_cmul","","Write the constant in binary and that gives you the shift…",35,[[["binarybundle",3]],[["result",4],["binarybundle",3]]]],[11,"bin_abs","","Compute the absolute value of a binary bundle.",35,[[["binarybundle",3]],[["result",4],["binarybundle",3]]]],[11,"bin_lt","","Returns 1 if `x < y`.",35,[[["binarybundle",3]],["result",4]]],[11,"bin_geq","","Returns 1 if `x >= y`.",35,[[["binarybundle",3]],["result",4]]],[11,"bin_max","","Compute the maximum bundle in `xs`.",35,[[],[["result",4],["binarybundle",3]]]],[11,"bin_demux","","Demux a binary bundle into a unary vector.",35,[[["binarybundle",3]],[["result",4],["vec",3]]]],[11,"constant_bundle","","Creates a bundle of constant wires using moduli `ps`.",36,[[],[["bundle",3],["result",4]]]],[11,"output_bundle","","Output the wires that make up a bundle.",36,[[["bundle",3]],[["result",4],["option",4]]]],[11,"output_bundles","","Output a slice of bundles.",36,[[],[["result",4],["option",4]]]],[11,"add_bundles","","Add two wire bundles pairwise, zipping addition.",36,[[["bundle",3]],[["bundle",3],["result",4]]]],[11,"sub_bundles","","Subtract two wire bundles, residue by residue.",36,[[["bundle",3]],[["bundle",3],["result",4]]]],[11,"mul_bundles","","Multiply each wire in `x` with each wire in `y`, pairwise.",36,[[["bundle",3]],[["bundle",3],["result",4]]]],[11,"mixed_radix_addition","","Mixed radix addition.",36,[[],[["bundle",3],["result",4]]]],[11,"mixed_radix_addition_msb_only","","Mixed radix addition only returning the MSB.",36,[[],["result",4]]],[11,"multiplex","","If b=0 then return x, else return y.",36,[[["bundle",3]],[["bundle",3],["result",4]]]],[11,"mask","","If b=0 then return 0, else return x.",36,[[["bundle",3]],[["bundle",3],["result",4]]]],[11,"shift","","Shift residues, replacing them with zeros in the modulus…",36,[[["bundle",3]],[["bundle",3],["result",4]]]],[11,"eq_bundles","","Compute `x == y`. Returns a wire encoding the result mod 2.",36,[[["bundle",3]],["result",4]]],[11,"crt_constant_bundle","","Creates a bundle of constant wires for the CRT…",37,[[],[["result",4],["crtbundle",3]]]],[11,"crt_output","","Output a CRT bundle and interpret it mod Q.",37,[[["crtbundle",3]],[["option",4],["result",4]]]],[11,"crt_outputs","","Output a slice of CRT bundles and interpret the outputs…",37,[[],[["result",4],["option",4]]]],[11,"crt_add","","Add two CRT bundles.",37,[[["crtbundle",3]],[["result",4],["crtbundle",3]]]],[11,"crt_sub","","Subtract two CRT bundles.",37,[[["crtbundle",3]],[["result",4],["crtbundle",3]]]],[11,"crt_cmul","","Multiplies each wire in `x` by the corresponding residue…",37,[[["crtbundle",3]],[["result",4],["crtbundle",3]]]],[11,"crt_mul","","Multiply `x` with `y`.",37,[[["crtbundle",3]],[["result",4],["crtbundle",3]]]],[11,"crt_cexp","","Exponentiate `x` by the constant `c`.",37,[[["crtbundle",3]],[["result",4],["crtbundle",3]]]],[11,"crt_rem","","Compute the remainder with respect to modulus `p`.",37,[[["crtbundle",3]],[["result",4],["crtbundle",3]]]],[11,"crt_fractional_mixed_radix","","Helper function for advanced gadgets, returns the MSB of…",37,[[["crtbundle",3]],["result",4]]],[11,"crt_relu","","Compute `max(x,0)`.",37,[[["crtbundle",3],["option",4]],[["result",4],["crtbundle",3]]]],[11,"crt_sign","","Return 0 if `x` is positive and 1 if `x` is negative.",37,[[["crtbundle",3]],["result",4]]],[11,"crt_sgn","","Return `if x >= 0 then 1 else -1`, where `-1` is…",37,[[["crtbundle",3],["option",4]],[["result",4],["crtbundle",3]]]],[11,"crt_lt","","Returns 1 if `x < y`.",37,[[["crtbundle",3]],["result",4]]],[11,"crt_geq","","Returns 1 if `x >= y`.",37,[[["crtbundle",3]],["result",4]]],[11,"crt_max","","Compute the maximum bundle in `xs`.",37,[[],[["result",4],["crtbundle",3]]]],[11,"encode","","Encode a single value.",38,[[],["result",4]]],[11,"receive","","Receive a single value form party `from`.",38,[[],["result",4]]],[11,"encode_bundle","","Encode a bundle.",38,[[],[["bundle",3],["result",4]]]],[11,"receive_bundle","","Receive a bundle of values from party `from`.",38,[[],[["bundle",3],["result",4]]]],[11,"encode_bundles","","Encode many input bundles.",38,[[],[["vec",3],["result",4]]]],[11,"receive_many_bundles","","Receive many input bundles from party `from`.",38,[[],[["vec",3],["result",4]]]],[11,"crt_encode","","Encode a CRT input bundle.",38,[[],[["crtbundle",3],["result",4]]]],[11,"crt_receive","","Receive an CRT input bundle from party `from`.",38,[[],[["crtbundle",3],["result",4]]]],[11,"crt_encode_many","","Encode many CRT input bundles.",38,[[],[["result",4],["vec",3]]]],[11,"crt_receive_many","","Receive many CRT input bundles from party `from`.",38,[[],[["result",4],["vec",3]]]],[11,"bin_encode","","Encode a binary input bundle.",38,[[],[["binarybundle",3],["result",4]]]],[11,"bin_receive","","Receive an binary input bundle from party `from`.",38,[[],[["binarybundle",3],["result",4]]]],[11,"bin_encode_many","","Encode many binary input bundles.",38,[[],[["result",4],["vec",3]]]],[11,"bin_receive_many","","Receive many binary input bundles from party `from`.",38,[[],[["result",4],["vec",3]]]],[11,"reveal_many","","Reveal a slice of items to all parties.",39,[[],[["result",4],["vec",3]]]],[11,"reveal_bundle","","Reveal a bundle to all parties.",39,[[["bundle",3]],[["result",4],["vec",3]]]],[11,"reveal_many_bundles","","Reveal many bundles to all parties.",39,[[],[["vec",3],["result",4]]]],[11,"crt_reveal","","Reveal a CRT bundle to all parties.",39,[[["crtbundle",3]],["result",4]]],[11,"crt_reveal_many","","Reveal many CRT bundles to all parties.",39,[[],[["vec",3],["result",4]]]],[11,"bin_reveal","","Reveal a binary bundle to all parties.",39,[[["binarybundle",3]],["result",4]]],[11,"bin_reveal_many","","Reveal many binary bundles to all parties.",39,[[],[["vec",3],["result",4]]]],[11,"add_many","","Sum up a slice of wires.",41,[[],["result",4]]],[11,"xor","","Xor is just addition, with the requirement that `x` and…",41,[[],["result",4]]],[11,"negate","","Negate by xoring `x` with `1`.",41,[[],["result",4]]],[11,"and","","And is just multiplication, with the requirement that `x`…",41,[[],["result",4]]],[11,"or","","Or uses Demorgan\'s Rule implemented with multiplication…",41,[[],["result",4]]],[11,"and_many","","Returns 1 if all wires equal 1.",41,[[],["result",4]]],[11,"or_many","","Returns 1 if any wire equals 1.",41,[[],["result",4]]],[11,"mod_change","","Change the modulus of `x` to `to_modulus` using a…",41,[[],["result",4]]],[11,"adder","","Binary adder. Returns the result and the carry.",41,[[["option",4]],["result",4]]],[11,"mux","","If `b = 0` returns `x` else `y`.",41,[[],["result",4]]],[11,"mux_constant_bits","","If `x = 0` returns the constant `b1` else return `b2`.…",41,[[],["result",4]]],[11,"outputs","","Output a slice of wires.",41,[[],[["result",4],["option",4]]]]],"p":[[4,"Wire"],[13,"Mod2"],[13,"Mod3"],[13,"ModN"],[3,"Circuit"],[3,"CircuitBuilder"],[3,"GarbledCircuit"],[3,"Encoder"],[3,"DummyVal"],[3,"Dummy"],[4,"FancyError"],[13,"InvalidArgNum"],[13,"InvalidArgMod"],[4,"DummyError"],[4,"EvaluatorError"],[4,"GarblerError"],[4,"CircuitBuilderError"],[4,"CircuitParserError"],[4,"TwopacError"],[3,"BinaryBundle"],[3,"Bundle"],[3,"CrtBundle"],[3,"Evaluator"],[3,"Garbler"],[3,"Informer"],[3,"InformerStats"],[4,"PartyId"],[3,"Evaluator"],[3,"Garbler"],[4,"PartyId"],[4,"Error"],[3,"Evaluator"],[4,"Error"],[3,"Garbler"],[8,"RngExt"],[8,"BinaryGadgets"],[8,"BundleGadgets"],[8,"CrtGadgets"],[8,"FancyInput"],[8,"FancyReveal"],[8,"HasModulus"],[8,"Fancy"],[3,"CircuitRef"]]},\
"ocelot":{"doc":"`ocelot`: A rust library for oblivious transfer","i":[[4,"Error","ocelot","Errors produced by `ocelot`.",null,null],[13,"InvalidInputLength","","The input length is invalid.",0,null],[13,"IoError","","An I/O error has occurred.",0,null],[13,"Other","","Some other error, given by `String`.",0,null],[13,"CoinTossError","","Coin tossing failed.",0,null],[0,"oprf","","Oblivious PRF traits + instantiations.",null,null],[0,"kkrt","ocelot::oprf","Implementation of the batched, related-key oblivious…",null,null],[3,"Sender","ocelot::oprf::kkrt","KKRT oblivious PRF sender.",null,null],[3,"Receiver","","KKRT oblivious PRF receiver.",null,null],[11,"encode","","Encode `input` into `output`. This is not the same as the…",1,[[]]],[0,"kmprt","ocelot::oprf","Implementation of the hash-based multi-use OPPRF of…",null,null],[3,"Sender","ocelot::oprf::kmprt","KMPRT hashing-based OPPRF sender.",null,null],[3,"Receiver","","KMPRT oblivious programmable PRF receiver.",null,null],[11,"init","","Initialize the OPPRF sender.",2,[[],[["error",4],["result",4]]]],[11,"send","","Run the OPPRF for `ninputs` inputs with the pairs given in…",2,[[],[["error",4],["result",4]]]],[11,"init","","Initialize the OPPRF receiver.",3,[[],[["error",4],["result",4]]]],[11,"receive","","Run the OPPRF on inputs provided by the `inputs` slice.",3,[[],[["error",4],["result",4],["vec",3]]]],[6,"KkrtSender","ocelot::oprf","KKRT oblivious PRF sender using ALSZ OT extension with…",null,null],[6,"KkrtReceiver","","KKRT oblivious PRF receiver using ALSZ OT extension with…",null,null],[6,"KmprtSender","","KMPRT hash-based OPPRF sender, using KKRT as the…",null,null],[6,"KmprtReceiver","","KMPRT hash-based OPPRF receiver, using KKRT as the…",null,null],[8,"ObliviousPrf","","Trait containing the associated types used by an oblivious…",null,null],[16,"Seed","","PRF seed.",4,null],[16,"Input","","PRF input.",4,null],[16,"Output","","PRF output.",4,null],[8,"Sender","","Trait for an oblivious PRF sender.",null,null],[10,"init","","Runs any one-time initialization.",5,[[],[["error",4],["result",4]]]],[10,"send","","Runs `m` OPRF instances as the sender, returning the OPRF…",5,[[],[["error",4],["result",4],["vec",3]]]],[10,"compute","","Computes the oblivious PRF on seed `seed` and input `input`.",5,[[]]],[8,"Receiver","","Trait for an oblivious PRF receiver.",null,null],[10,"init","","Runs any one-time initialization.",6,[[],[["error",4],["result",4]]]],[10,"receive","","Runs the oblivious PRF on inputs `inputs`, returning the…",6,[[],[["vec",3],["result",4],["error",4]]]],[0,"ot","ocelot","Oblivious transfer traits + instantiations.",null,null],[0,"alsz","ocelot::ot","Implementation of the Asharov-Lindell-Schneider-Zohner…",null,null],[3,"Sender","ocelot::ot::alsz","Oblivious transfer sender.",null,null],[3,"Receiver","","Oblivious transfer receiver.",null,null],[0,"chou_orlandi","ocelot::ot","Implementation of the Chou-Orlandi oblivious transfer…",null,null],[3,"Sender","ocelot::ot::chou_orlandi","Oblivious transfer sender.",null,null],[3,"Receiver","","Oblivious transfer receiver.",null,null],[0,"dummy","ocelot::ot","Implementation of an entirely insecure oblivious transfer…",null,null],[3,"Sender","ocelot::ot::dummy","Oblivious transfer sender.",null,null],[3,"Receiver","","Oblivious transfer receiver.",null,null],[0,"kos","ocelot::ot","Implementation of the Keller-Orsini-Scholl oblivious…",null,null],[3,"Sender","ocelot::ot::kos","Oblivious transfer extension sender.",null,null],[3,"Receiver","","Oblivious transfer extension receiver.",null,null],[0,"naor_pinkas","ocelot::ot","Implementation of the Naor-Pinkas oblivious transfer…",null,null],[3,"Sender","ocelot::ot::naor_pinkas","Oblivious transfer sender.",null,null],[3,"Receiver","","Oblivious transfer receiver.",null,null],[6,"ChouOrlandiSender","ocelot::ot","Instantiation of the Chou-Orlandi OT sender.",null,null],[6,"ChouOrlandiReceiver","","Instantiation of the Chou-Orlandi OT receiver.",null,null],[6,"DummySender","","Instantiation of the dummy OT sender.",null,null],[6,"DummyReceiver","","Instantiation of the dummy OT receiver.",null,null],[6,"NaorPinkasSender","","Instantiation of the Naor-Pinkas OT sender.",null,null],[6,"NaorPinkasReceiver","","Instantiation of the Naor-Pinkas OT receiver.",null,null],[6,"AlszSender","","Instantiation of the ALSZ OT extension sender, using…",null,null],[6,"AlszReceiver","","Instantiation of the ALSZ OT extension receiver, using…",null,null],[6,"KosSender","","Instantiation of the KOS OT extension sender, using…",null,null],[6,"KosReceiver","","Instantiation of the KOS OT extension receiver, using…",null,null],[8,"Sender","","Trait for one-out-of-two oblivious transfer from the…",null,null],[16,"Msg","","Message type, restricted to types that are…",7,null],[10,"init","","Runs any one-time initialization to create the oblivious…",7,[[],[["error",4],["result",4]]]],[10,"send","","Sends messages.",7,[[],[["error",4],["result",4]]]],[8,"Receiver","","Trait for one-out-of-two oblivious transfer from the…",null,null],[16,"Msg","","Message type, restricted to types that are…",8,null],[10,"init","","Runs any one-time initialization to create the oblivious…",8,[[],[["error",4],["result",4]]]],[10,"receive","","Receives messages.",8,[[],[["result",4],["vec",3],["error",4]]]],[8,"CorrelatedSender","","Trait for one-out-of-two correlated oblivious transfer…",null,null],[10,"send_correlated","","Correlated oblivious transfer send. Takes as input an…",9,[[],[["error",4],["vec",3],["result",4]]]],[8,"CorrelatedReceiver","","Trait for one-out-of-two correlated oblivious transfer…",null,null],[10,"receive_correlated","","Correlated oblivious transfer receive.",10,[[],[["result",4],["vec",3],["error",4]]]],[8,"RandomSender","","Trait for one-out-of-two random oblivious transfer from…",null,null],[10,"send_random","","Random oblivious transfer send. Returns a vector of tuples…",11,[[],[["error",4],["vec",3],["result",4]]]],[8,"RandomReceiver","","Trait for one-out-of-two random oblivious transfer from…",null,null],[10,"receive_random","","Random oblivious transfer receive.",12,[[],[["result",4],["vec",3],["error",4]]]],[11,"from","ocelot","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from_cast","","",0,[[]]],[11,"cast","","",0,[[]]],[11,"from_bits","","",0,[[]]],[11,"into_bits","","",0,[[]]],[11,"vzip","","",0,[[]]],[11,"from","ocelot::oprf::kkrt","",1,[[]]],[11,"into","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from_cast","","",1,[[]]],[11,"cast","","",1,[[]]],[11,"from_bits","","",1,[[]]],[11,"into_bits","","",1,[[]]],[11,"vzip","","",1,[[]]],[11,"from","","",13,[[]]],[11,"into","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"try_into","","",13,[[],["result",4]]],[11,"borrow","","",13,[[]]],[11,"borrow_mut","","",13,[[]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"from_cast","","",13,[[]]],[11,"cast","","",13,[[]]],[11,"from_bits","","",13,[[]]],[11,"into_bits","","",13,[[]]],[11,"vzip","","",13,[[]]],[11,"from","ocelot::oprf::kmprt","",2,[[]]],[11,"into","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from_cast","","",2,[[]]],[11,"cast","","",2,[[]]],[11,"from_bits","","",2,[[]]],[11,"into_bits","","",2,[[]]],[11,"vzip","","",2,[[]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from_cast","","",3,[[]]],[11,"cast","","",3,[[]]],[11,"from_bits","","",3,[[]]],[11,"into_bits","","",3,[[]]],[11,"vzip","","",3,[[]]],[11,"from","ocelot::ot::alsz","",14,[[]]],[11,"into","","",14,[[]]],[11,"to_string","","",14,[[],["string",3]]],[11,"try_from","","",14,[[],["result",4]]],[11,"try_into","","",14,[[],["result",4]]],[11,"borrow","","",14,[[]]],[11,"borrow_mut","","",14,[[]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"from_cast","","",14,[[]]],[11,"cast","","",14,[[]]],[11,"from_bits","","",14,[[]]],[11,"into_bits","","",14,[[]]],[11,"vzip","","",14,[[]]],[11,"from","","",15,[[]]],[11,"into","","",15,[[]]],[11,"to_string","","",15,[[],["string",3]]],[11,"try_from","","",15,[[],["result",4]]],[11,"try_into","","",15,[[],["result",4]]],[11,"borrow","","",15,[[]]],[11,"borrow_mut","","",15,[[]]],[11,"type_id","","",15,[[],["typeid",3]]],[11,"from_cast","","",15,[[]]],[11,"cast","","",15,[[]]],[11,"from_bits","","",15,[[]]],[11,"into_bits","","",15,[[]]],[11,"vzip","","",15,[[]]],[11,"from","ocelot::ot::chou_orlandi","",16,[[]]],[11,"into","","",16,[[]]],[11,"to_string","","",16,[[],["string",3]]],[11,"try_from","","",16,[[],["result",4]]],[11,"try_into","","",16,[[],["result",4]]],[11,"borrow","","",16,[[]]],[11,"borrow_mut","","",16,[[]]],[11,"type_id","","",16,[[],["typeid",3]]],[11,"from_cast","","",16,[[]]],[11,"cast","","",16,[[]]],[11,"from_bits","","",16,[[]]],[11,"into_bits","","",16,[[]]],[11,"vzip","","",16,[[]]],[11,"from","","",17,[[]]],[11,"into","","",17,[[]]],[11,"to_string","","",17,[[],["string",3]]],[11,"try_from","","",17,[[],["result",4]]],[11,"try_into","","",17,[[],["result",4]]],[11,"borrow","","",17,[[]]],[11,"borrow_mut","","",17,[[]]],[11,"type_id","","",17,[[],["typeid",3]]],[11,"from_cast","","",17,[[]]],[11,"cast","","",17,[[]]],[11,"from_bits","","",17,[[]]],[11,"into_bits","","",17,[[]]],[11,"vzip","","",17,[[]]],[11,"from","ocelot::ot::dummy","",18,[[]]],[11,"into","","",18,[[]]],[11,"to_string","","",18,[[],["string",3]]],[11,"try_from","","",18,[[],["result",4]]],[11,"try_into","","",18,[[],["result",4]]],[11,"borrow","","",18,[[]]],[11,"borrow_mut","","",18,[[]]],[11,"type_id","","",18,[[],["typeid",3]]],[11,"from_cast","","",18,[[]]],[11,"cast","","",18,[[]]],[11,"from_bits","","",18,[[]]],[11,"into_bits","","",18,[[]]],[11,"vzip","","",18,[[]]],[11,"from","","",19,[[]]],[11,"into","","",19,[[]]],[11,"to_string","","",19,[[],["string",3]]],[11,"try_from","","",19,[[],["result",4]]],[11,"try_into","","",19,[[],["result",4]]],[11,"borrow","","",19,[[]]],[11,"borrow_mut","","",19,[[]]],[11,"type_id","","",19,[[],["typeid",3]]],[11,"from_cast","","",19,[[]]],[11,"cast","","",19,[[]]],[11,"from_bits","","",19,[[]]],[11,"into_bits","","",19,[[]]],[11,"vzip","","",19,[[]]],[11,"from","ocelot::ot::kos","",20,[[]]],[11,"into","","",20,[[]]],[11,"to_string","","",20,[[],["string",3]]],[11,"try_from","","",20,[[],["result",4]]],[11,"try_into","","",20,[[],["result",4]]],[11,"borrow","","",20,[[]]],[11,"borrow_mut","","",20,[[]]],[11,"type_id","","",20,[[],["typeid",3]]],[11,"from_cast","","",20,[[]]],[11,"cast","","",20,[[]]],[11,"from_bits","","",20,[[]]],[11,"into_bits","","",20,[[]]],[11,"vzip","","",20,[[]]],[11,"from","","",21,[[]]],[11,"into","","",21,[[]]],[11,"to_string","","",21,[[],["string",3]]],[11,"try_from","","",21,[[],["result",4]]],[11,"try_into","","",21,[[],["result",4]]],[11,"borrow","","",21,[[]]],[11,"borrow_mut","","",21,[[]]],[11,"type_id","","",21,[[],["typeid",3]]],[11,"from_cast","","",21,[[]]],[11,"cast","","",21,[[]]],[11,"from_bits","","",21,[[]]],[11,"into_bits","","",21,[[]]],[11,"vzip","","",21,[[]]],[11,"from","ocelot::ot::naor_pinkas","",22,[[]]],[11,"into","","",22,[[]]],[11,"to_string","","",22,[[],["string",3]]],[11,"try_from","","",22,[[],["result",4]]],[11,"try_into","","",22,[[],["result",4]]],[11,"borrow","","",22,[[]]],[11,"borrow_mut","","",22,[[]]],[11,"type_id","","",22,[[],["typeid",3]]],[11,"from_cast","","",22,[[]]],[11,"cast","","",22,[[]]],[11,"from_bits","","",22,[[]]],[11,"into_bits","","",22,[[]]],[11,"vzip","","",22,[[]]],[11,"from","","",23,[[]]],[11,"into","","",23,[[]]],[11,"to_string","","",23,[[],["string",3]]],[11,"try_from","","",23,[[],["result",4]]],[11,"try_into","","",23,[[],["result",4]]],[11,"borrow","","",23,[[]]],[11,"borrow_mut","","",23,[[]]],[11,"type_id","","",23,[[],["typeid",3]]],[11,"from_cast","","",23,[[]]],[11,"cast","","",23,[[]]],[11,"from_bits","","",23,[[]]],[11,"into_bits","","",23,[[]]],[11,"vzip","","",23,[[]]],[11,"init","ocelot::oprf::kkrt","",1,[[],[["error",4],["result",4]]]],[11,"send","","",1,[[],[["error",4],["result",4],["vec",3]]]],[11,"compute","","",1,[[]]],[11,"init","","",13,[[],[["error",4],["result",4]]]],[11,"receive","","",13,[[],[["vec",3],["result",4],["error",4]]]],[11,"init","ocelot::ot::alsz","",14,[[],[["error",4],["result",4]]]],[11,"send","","",14,[[],[["error",4],["result",4]]]],[11,"init","ocelot::ot::chou_orlandi","",16,[[],[["error",4],["result",4]]]],[11,"send","","",16,[[],[["error",4],["result",4]]]],[11,"init","ocelot::ot::dummy","",18,[[],[["error",4],["result",4]]]],[11,"send","","",18,[[],[["error",4],["result",4]]]],[11,"init","ocelot::ot::kos","",20,[[],[["error",4],["result",4]]]],[11,"send","","",20,[[],[["error",4],["result",4]]]],[11,"init","ocelot::ot::naor_pinkas","",22,[[],[["error",4],["result",4]]]],[11,"send","","",22,[[],[["error",4],["result",4]]]],[11,"init","ocelot::ot::alsz","",15,[[],[["error",4],["result",4]]]],[11,"receive","","",15,[[],[["result",4],["vec",3],["error",4]]]],[11,"init","ocelot::ot::chou_orlandi","",17,[[],[["error",4],["result",4]]]],[11,"receive","","",17,[[],[["vec",3],["error",4],["result",4]]]],[11,"init","ocelot::ot::dummy","",19,[[],[["error",4],["result",4]]]],[11,"receive","","",19,[[],[["vec",3],["error",4],["result",4]]]],[11,"init","ocelot::ot::kos","",21,[[],[["error",4],["result",4]]]],[11,"receive","","",21,[[],[["vec",3],["error",4],["result",4]]]],[11,"init","ocelot::ot::naor_pinkas","",23,[[],[["error",4],["result",4]]]],[11,"receive","","",23,[[],[["vec",3],["error",4],["result",4]]]],[11,"send_correlated","ocelot::ot::alsz","",14,[[],[["error",4],["vec",3],["result",4]]]],[11,"send_correlated","ocelot::ot::kos","",20,[[],[["error",4],["vec",3],["result",4]]]],[11,"receive_correlated","ocelot::ot::alsz","",15,[[],[["result",4],["vec",3],["error",4]]]],[11,"receive_correlated","ocelot::ot::kos","",21,[[],[["result",4],["vec",3],["error",4]]]],[11,"send_random","ocelot::ot::alsz","",14,[[],[["error",4],["vec",3],["result",4]]]],[11,"send_random","ocelot::ot::kos","",20,[[],[["error",4],["vec",3],["result",4]]]],[11,"receive_random","ocelot::ot::alsz","",15,[[],[["result",4],["vec",3],["error",4]]]],[11,"receive_random","ocelot::ot::kos","",21,[[],[["result",4],["vec",3],["error",4]]]],[11,"from","ocelot","",0,[[["error",3]],["error",4]]],[11,"from","","",0,[[["error",4]],["error",4]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","ocelot::ot::alsz","",14,[[["formatter",3]],["result",6]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"fmt","ocelot::ot::chou_orlandi","",16,[[["formatter",3]],["result",6]]],[11,"fmt","","",17,[[["formatter",3]],["result",6]]],[11,"fmt","ocelot::ot::dummy","",18,[[["formatter",3]],["result",6]]],[11,"fmt","","",19,[[["formatter",3]],["result",6]]],[11,"fmt","ocelot::ot::kos","",20,[[["formatter",3]],["result",6]]],[11,"fmt","","",21,[[["formatter",3]],["result",6]]],[11,"fmt","ocelot::ot::naor_pinkas","",22,[[["formatter",3]],["result",6]]],[11,"fmt","","",23,[[["formatter",3]],["result",6]]]],"p":[[4,"Error"],[3,"Sender"],[3,"Sender"],[3,"Receiver"],[8,"ObliviousPrf"],[8,"Sender"],[8,"Receiver"],[8,"Sender"],[8,"Receiver"],[8,"CorrelatedSender"],[8,"CorrelatedReceiver"],[8,"RandomSender"],[8,"RandomReceiver"],[3,"Receiver"],[3,"Sender"],[3,"Receiver"],[3,"Sender"],[3,"Receiver"],[3,"Sender"],[3,"Receiver"],[3,"Sender"],[3,"Receiver"],[3,"Sender"],[3,"Receiver"]]},\
"popsicle":{"doc":"`popsicle`: A rust library for private set intersection","i":[[4,"Error","popsicle","Errors produced by the private set intersection protocols.",null,null],[13,"CoinTossError","","Coin tossing failed.",0,null],[13,"OprfError","","The underlying oblivious PRF failed.",0,null],[13,"IoError","","An input/output error occurred.",0,null],[13,"CuckooHashFull","","The cuckoo hash is full.",0,null],[13,"InvalidCuckooSetSize","","The provided cuckoo hash set size is invalid.",0,null],[13,"InvalidCuckooParameters","","The provided cuckoo hash parameters are invalid.",0,null],[12,"nitems","popsicle::Error","Number of items.",1,null],[12,"nhashes","","Number of hashes.",1,null],[13,"PsiProtocolError","popsicle","An error occurred in the PSI protocol.",0,null],[13,"InvalidPayloadsLength","","Not enough payloads.",0,null],[13,"SSLError","","SSL Error",0,null],[13,"TwopcError","","An error occurred in the underlying 2PC protocol.",0,null],[0,"kmprt","","Implementation of the…",null,null],[3,"Sender","popsicle::kmprt","KMPRT sender - there can be many of these.",null,null],[3,"Receiver","","KMPRT receiver - there can only be one of these.",null,null],[6,"PartyId","","The party number for each party.",null,null],[0,"psty","popsicle","Implementation of the Pinkas-Schneider-Tkachenko-Yanai…",null,null],[3,"Sender","popsicle::psty","Private set intersection sender.",null,null],[3,"SenderState","","State of the sender.",null,null],[3,"Receiver","","Private set intersection receiver.",null,null],[3,"ReceiverState","","State of the receiver.",null,null],[6,"Msg","","The type of values in the sender and receiver\'s sets.",null,null],[0,"psz","popsicle","Implementation of the Pinkas-Schneider-Zohner private set…",null,null],[3,"Sender","popsicle::psz","Private set intersection sender.",null,null],[3,"Receiver","","Private set intersection receiver.",null,null],[6,"Sender","popsicle","Private set intersection sender.",null,null],[6,"Receiver","","Private set intersection receiver.",null,null],[6,"ExtendedSender","","Extended private set intersection sender.",null,null],[6,"ExtendedReceiver","","Extended private set intersection receiver.",null,null],[6,"MultiPartySender","","Multi-party private set intersection sender.",null,null],[6,"MultiPartyReceiver","","Multi-party private set intersection receiver.",null,null],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from_cast","","",0,[[]]],[11,"cast","","",0,[[]]],[11,"from_bits","","",0,[[]]],[11,"into_bits","","",0,[[]]],[11,"vzip","","",0,[[]]],[11,"from","popsicle::kmprt","",2,[[]]],[11,"into","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from_cast","","",2,[[]]],[11,"cast","","",2,[[]]],[11,"from_bits","","",2,[[]]],[11,"into_bits","","",2,[[]]],[11,"vzip","","",2,[[]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from_cast","","",3,[[]]],[11,"cast","","",3,[[]]],[11,"from_bits","","",3,[[]]],[11,"into_bits","","",3,[[]]],[11,"vzip","","",3,[[]]],[11,"from","popsicle::psty","",4,[[]]],[11,"into","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from_cast","","",4,[[]]],[11,"cast","","",4,[[]]],[11,"from_bits","","",4,[[]]],[11,"into_bits","","",4,[[]]],[11,"vzip","","",4,[[]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from_cast","","",5,[[]]],[11,"cast","","",5,[[]]],[11,"from_bits","","",5,[[]]],[11,"into_bits","","",5,[[]]],[11,"vzip","","",5,[[]]],[11,"from","","",6,[[]]],[11,"into","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from_cast","","",6,[[]]],[11,"cast","","",6,[[]]],[11,"from_bits","","",6,[[]]],[11,"into_bits","","",6,[[]]],[11,"vzip","","",6,[[]]],[11,"from","","",7,[[]]],[11,"into","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from_cast","","",7,[[]]],[11,"cast","","",7,[[]]],[11,"from_bits","","",7,[[]]],[11,"into_bits","","",7,[[]]],[11,"vzip","","",7,[[]]],[11,"from","popsicle::psz","",8,[[]]],[11,"into","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"from_cast","","",8,[[]]],[11,"cast","","",8,[[]]],[11,"from_bits","","",8,[[]]],[11,"into_bits","","",8,[[]]],[11,"vzip","","",8,[[]]],[11,"from","","",9,[[]]],[11,"into","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"try_into","","",9,[[],["result",4]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"from_cast","","",9,[[]]],[11,"cast","","",9,[[]]],[11,"from_bits","","",9,[[]]],[11,"into_bits","","",9,[[]]],[11,"vzip","","",9,[[]]],[11,"from","popsicle","",0,[[["errorstack",3]],["error",4]]],[11,"from","","",0,[[["error",3]],["error",4]]],[11,"from","","",0,[[["error",4]],["error",4]]],[11,"from","","",0,[[["error",4]],["error",4]]],[11,"from","","",0,[[["twopacerror",4]],["error",4]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"init","popsicle::kmprt","Initialize a PSI sender.",2,[[["partyid",6]],[["error",4],["result",4]]]],[11,"send","","Send inputs to all parties and particpate in one party…",2,[[],[["error",4],["result",4]]]],[11,"init","","Initialize the PSI receiver.",3,[[],[["error",4],["result",4]]]],[11,"receive","","Send inputs and receive result - only one party should…",3,[[],[["error",4],["result",4],["vec",3]]]],[11,"init","popsicle::psty","Initialize the PSI sender.",4,[[],[["error",4],["result",4]]]],[11,"send","","Run the PSI protocol over `inputs`.",4,[[],[["result",4],["senderstate",3],["error",4]]]],[11,"compute_setup","","Run the setup phase, producing a garbler for the next stage.",5,[[],[["error",4],["result",4]]]],[11,"compute_intersection","","Compute the intersection.",5,[[],[["error",4],["result",4]]]],[11,"compute_cardinality","","Compute the cardinality of the intersection.",5,[[],[["error",4],["result",4]]]],[11,"receive_payloads","","Receive encrypted payloads from the Sender.",5,[[],[["vec",3],["error",4],["result",4]]]],[11,"init","","Initialize the PSI receiver.",6,[[],[["error",4],["result",4]]]],[11,"receive","","Run the PSI protocol over `inputs`.",6,[[],[["error",4],["result",4],["receiverstate",3]]]],[11,"compute_setup","","Run the setup phase, producing an evaluator for the next…",7,[[],[["error",4],["result",4]]]],[11,"compute_intersection","","Compute the intersection.",7,[[],[["error",4],["vec",3],["result",4]]]],[11,"compute_cardinality","","Compute the cardinality of the intersection.",7,[[],[["error",4],["result",4]]]],[11,"send_payloads","","Send encrypted payloads to the Receiver, who can only…",7,[[],[["error",4],["result",4]]]],[11,"init","popsicle::psz","Initialize the PSI sender.",8,[[],[["error",4],["result",4]]]],[11,"send","","Run the PSI protocol over `inputs`.",8,[[],[["error",4],["result",4]]]],[11,"send_payloads","","Run the PSI protocol over `inputs`. Returns a random key…",8,[[],[["error",4],["result",4],["vec",3]]]],[11,"init","","Initialize the PSI receiver.",9,[[],[["error",4],["result",4]]]],[11,"receive","","Run the PSI protocol over `inputs`.",9,[[],[["vec",3],["error",4],["result",4]]]],[11,"receive_payloads","","Run the PSI protocol over `inputs`, receiving a vector of…",9,[[],[["hashmap",3],["error",4],["result",4]]]]],"p":[[4,"Error"],[13,"InvalidCuckooParameters"],[3,"Sender"],[3,"Receiver"],[3,"Sender"],[3,"SenderState"],[3,"Receiver"],[3,"ReceiverState"],[3,"Sender"],[3,"Receiver"]]},\
"scuttlebutt":{"doc":"The `scuttlebutt` multi-party computation utilities…","i":[[3,"Aes128","scuttlebutt","AES-128, encryption only.",null,null],[3,"Aes256","","AES-256, encryption only.",null,null],[3,"Block","","A 128-bit chunk.",null,null],[12,"0","","",0,null],[3,"Block512","","A 512-bit value.",null,null],[3,"HashChannel","","An instantiation of the `AbstractChannel` trait which…",null,null],[3,"TrackChannel","","A channel for tracking the number of bits read/written.",null,null],[3,"AesHash","","AES-based correlation-robust hash function.",null,null],[3,"AesRng","","Implementation of a random number generator based on…",null,null],[3,"UniversalDigest","","Implementation of subtraits of `Digest` trait based on a…",null,null],[5,"track_unix_channel_pair","","Convenience function to create a pair of TrackUnixChannels…",null,[[]]],[5,"unix_channel_pair","","Convenience function to create a pair of UnixChannels for…",null,[[]]],[11,"new","","Create a new `Aes128` object, using `key` as the AES key.",1,[[["block",3]]]],[11,"encrypt","","Encrypt a block, outputting the ciphertext.",1,[[["block",3]],["block",3]]],[11,"encrypt4","","Encrypt four blocks at a time, outputting the ciphertexts.",1,[[]]],[11,"encrypt8","","Encrypt eight blocks at a time, outputting the ciphertexts.",1,[[]]],[11,"new","","Make a new `Aes256` object with key `key`.",2,[[]]],[11,"encrypt","","Encrypt block `m`.",2,[[["block",3]],["block",3]]],[11,"as_ptr","","Convert into a pointer.",0,[[]]],[11,"as_mut_ptr","","Convert into a mutable pointer.",0,[[]]],[11,"clmul","","Carryless multiplication.",0,[[]]],[11,"hash_pt","","Hash an elliptic curve point `pt` and tweak `tweak`.",0,[[["ristrettopoint",3]]]],[11,"lsb","","Return the least significant bit.",0,[[]]],[11,"set_lsb","","Set the least significant bit.",0,[[],["block",3]]],[11,"flip","","Flip all bits.",0,[[]]],[11,"try_from_slice","","Try to create a `Block` from a slice of bytes. The slice…",0,[[],["option",4]]],[11,"prefix","","Return the first `n` bytes, where `n` must be `<= 64`.",3,[[]]],[11,"prefix_mut","","Return the first `n` bytes as mutable, where `n` must be…",3,[[]]],[0,"bloomfilter","","Implementation of a bloom filter.",null,null],[3,"BloomFilter","scuttlebutt::bloomfilter","Simple implementation of a Bloom Filter. Which is…",null,null],[11,"new","","Create a new BloomFilter with `size` entries, using…",4,[[]]],[11,"compute_expansion","","Compute required expansion for false positive probability…",4,[[]]],[11,"compute_nhashes","","Compute required number of hash functions for false…",4,[[]]],[11,"with_false_positive_prob","","Create a new BloomFilter with false positive probability…",4,[[]]],[11,"len","","Get the number of bins in this BloomFilter.",4,[[]]],[11,"nhashes","","Get the number of hash functions in this BloomFilter.",4,[[]]],[11,"bins","","Get bloom filter bins.",4,[[]]],[11,"as_bytes","","Get bloom filter bins packed in bytes.",4,[[],["vec",3]]],[11,"from_bytes","","Create bloom filter from bytes.",4,[[]]],[11,"bin","","Compute the bin that this value would go to in a…",4,[[]]],[11,"insert","","Insert an item into the BloomFilter.",4,[[]]],[11,"contains","","Check whether an item exists in the BloomFilter.",4,[[]]],[0,"channel","scuttlebutt","Module for encapsulating communication channels for…",null,null],[3,"HashChannel","scuttlebutt::channel","An instantiation of the `AbstractChannel` trait which…",null,null],[3,"TrackChannel","","A channel for tracking the number of bits read/written.",null,null],[3,"Channel","","A standard read/write channel that implements…",null,null],[12,"reader","","",5,null],[12,"writer","","",5,null],[5,"track_unix_channel_pair","","Convenience function to create a pair of TrackUnixChannels…",null,[[]]],[5,"unix_channel_pair","","Convenience function to create a pair of UnixChannels for…",null,[[]]],[11,"new","scuttlebutt","Make a new `HashChannel` from a `reader` and a `writer`.",6,[[]]],[11,"finish","","Consume the channel and output the hash of all the…",6,[[]]],[11,"new","","Make a new `TrackChannel` from a `reader` and a `writer`.",7,[[]]],[11,"clear","","Clear the number of bits read/written.",7,[[]]],[11,"kilobits_written","","Return the number of kilobits written to the channel.",7,[[]]],[11,"kilobits_read","","Return the number of kilobits read from the channel.",7,[[]]],[11,"total_kilobits","","Return the total amount of communication on the channel.",7,[[]]],[11,"kilobytes_written","","Return the number of kilobytes written to the channel.",7,[[]]],[11,"kilobytes_read","","Return the number of kilobytes read from the channel.",7,[[]]],[11,"total_kilobytes","","Return the total amount of communication on the channel as…",7,[[]]],[6,"TrackUnixChannel","scuttlebutt::channel","A TrackChannel which uses UnixStreams.",null,null],[6,"UnixChannel","","A Channel which uses UnixStreams.",null,null],[8,"AbstractChannel","","A trait for managing I/O. `AbstractChannel`s are…",null,null],[11,"read_vec","","Read `nbytes` from the channel, and return it as a `Vec`.",8,[[],[["result",6],["vec",3]]]],[11,"write_bool","","Write a `bool` to the channel.",8,[[],["result",6]]],[11,"read_bool","","Read a `bool` from the channel.",8,[[],["result",6]]],[11,"write_u8","","Write a `u8` to the channel.",8,[[],["result",6]]],[11,"read_u8","","Read a `u8` from the channel.",8,[[],["result",6]]],[11,"write_u16","","Write a `u16` to the channel.",8,[[],["result",6]]],[11,"read_u16","","Read a `u16` from the channel.",8,[[],["result",6]]],[11,"write_u32","","Write a `u32` to the channel.",8,[[],["result",6]]],[11,"read_u32","","Read a `u32` from the channel.",8,[[],["result",6]]],[11,"write_u64","","Write a `u64` to the channel.",8,[[],["result",6]]],[11,"read_u64","","Read a `u64` from the channel.",8,[[],["result",6]]],[11,"write_usize","","Write a `usize` to the channel.",8,[[],["result",6]]],[11,"read_usize","","Read a `usize` from the channel.",8,[[],["result",6]]],[11,"write_block","","Write a `Block` to the channel.",8,[[["block",3]],["result",6]]],[11,"read_block","","Read a `Block` from the channel.",8,[[],[["result",6],["block",3]]]],[11,"read_blocks","","Read `n` `Block`s from the channel.",8,[[],[["result",6],["vec",3]]]],[11,"write_block512","","Write a `Block512` to the channel.",8,[[["block512",3]],["result",6]]],[11,"read_block512","","Read a `Block512` from the channel.",8,[[],[["result",6],["block512",3]]]],[11,"write_pt","","Write a `RistrettoPoint` to the channel.",8,[[["ristrettopoint",3]],["result",6]]],[11,"read_pt","","Read a `RistrettoPoint` from the channel.",8,[[],[["ristrettopoint",3],["result",6]]]],[11,"new","","Make a new `Channel` from a `reader` and a `writer`.",5,[[]]],[0,"cointoss","scuttlebutt","Implementation of a simple two-party coin tossing protocol…",null,null],[4,"Error","scuttlebutt::cointoss","Errors produced by the coin tossing protocol.",null,null],[13,"IoError","","An I/O error occurred.",9,null],[13,"CommitmentCheckFailed","","The commitment check failed.",9,null],[5,"send","","Coin tossing sender.",null,[[],[["result",4],["vec",3],["error",4]]]],[5,"receive","","Coin tossing receiver.",null,[[],[["result",4],["vec",3],["error",4]]]],[0,"commitment","scuttlebutt","A trait defining a Commitment Scheme and an implementation…",null,null],[3,"ShaCommitment","scuttlebutt::commitment","A commitment in the random oracle model using SHA256.",null,null],[12,"seed","","The seed used to initialize the commitment.",10,null],[8,"Commitment","","Generic commitment scheme.",null,null],[16,"Seed","","The type used to initialize a commitment.",11,null],[16,"Output","","The output type of the commitment.",11,null],[10,"new","","A new commitment initialized with `seed`.",11,[[]]],[10,"input","","A method to add data to the commitment.",11,[[]]],[10,"finish","","Complete the commitment.",11,[[]]],[10,"check","","Check if two commitments are equal.",11,[[]]],[11,"new","scuttlebutt","Initialize the hash function using `key`.",12,[[["block",3]]]],[11,"cr_hash","","Correlation-robust hash function for 128-bit inputs (cf.…",12,[[["block",3]],["block",3]]],[11,"ccr_hash","","Circular correlation-robust hash function (cf.…",12,[[["block",3]],["block",3]]],[11,"tccr_hash","","Tweakable circular correlation robust hash function (cf.…",12,[[["block",3]],["block",3]]],[11,"new","","Create a new random number generator using a random seed…",13,[[]]],[11,"fork","","Create a new RNG using a random seed from this one.",13,[[]]],[0,"utils","","Useful utility functions.",null,null],[5,"pack_bits","scuttlebutt::utils","Pack a bit slice into bytes.",null,[[],["vec",3]]],[5,"unpack_bits","","Unpack a bit vector from a slice of bytes.",null,[[],["vec",3]]],[5,"xor","","XOR two byte arrays, outputting the result.",null,[[],["vec",3]]],[5,"xor_n","","XOR two byte arrays up to `n` bytes, outputting the result.",null,[[],["vec",3]]],[5,"xor_inplace","","XOR two byte arrays in place.",null,[[]]],[5,"xor_inplace_n","","XOR two byte arrays up to `n` bytes in place.",null,[[]]],[5,"and","","AND two byte arrays, outputting the result.",null,[[],["vec",3]]],[5,"and_inplace","","AND two byte arrays in place.",null,[[]]],[11,"new","scuttlebutt","Create a `UniversalDigest` with the given `key`, which…",14,[[["genericarray",3]]]],[6,"TrackUnixChannel","","A TrackChannel which uses UnixStreams.",null,null],[6,"UnixChannel","","A Channel which uses UnixStreams.",null,null],[17,"FIXED_KEY_AES128","","Fixed-key AES-128.",null,null],[17,"AES_HASH","","`AesHash` with a fixed key.",null,null],[8,"SemiHonest","","A marker trait denoting that the given scheme is…",null,null],[8,"Malicious","","A marker trait denoting that the given scheme is…",null,null],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from_cast","","",1,[[]]],[11,"cast","","",1,[[]]],[11,"from_bits","","",1,[[]]],[11,"into_bits","","",1,[[]]],[11,"vzip","","",1,[[]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from_cast","","",2,[[]]],[11,"cast","","",2,[[]]],[11,"from_bits","","",2,[[]]],[11,"into_bits","","",2,[[]]],[11,"vzip","","",2,[[]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from_cast","","",0,[[]]],[11,"cast","","",0,[[]]],[11,"from_bits","","",0,[[]]],[11,"into_bits","","",0,[[]]],[11,"vzip","","",0,[[]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"to_owned","","",3,[[]]],[11,"clone_into","","",3,[[]]],[11,"to_string","","",3,[[],["string",3]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from_cast","","",3,[[]]],[11,"cast","","",3,[[]]],[11,"from_bits","","",3,[[]]],[11,"into_bits","","",3,[[]]],[11,"vzip","","",3,[[]]],[11,"from","","",6,[[]]],[11,"into","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from_cast","","",6,[[]]],[11,"cast","","",6,[[]]],[11,"from_bits","","",6,[[]]],[11,"into_bits","","",6,[[]]],[11,"vzip","","",6,[[]]],[11,"from","","",7,[[]]],[11,"into","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from_cast","","",7,[[]]],[11,"cast","","",7,[[]]],[11,"from_bits","","",7,[[]]],[11,"into_bits","","",7,[[]]],[11,"vzip","","",7,[[]]],[11,"from","","",12,[[]]],[11,"into","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"try_into","","",12,[[],["result",4]]],[11,"borrow","","",12,[[]]],[11,"borrow_mut","","",12,[[]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"from_cast","","",12,[[]]],[11,"cast","","",12,[[]]],[11,"from_bits","","",12,[[]]],[11,"into_bits","","",12,[[]]],[11,"vzip","","",12,[[]]],[11,"from","","",13,[[]]],[11,"into","","",13,[[]]],[11,"to_owned","","",13,[[]]],[11,"clone_into","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"try_into","","",13,[[],["result",4]]],[11,"borrow","","",13,[[]]],[11,"borrow_mut","","",13,[[]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"from_cast","","",13,[[]]],[11,"cast","","",13,[[]]],[11,"from_bits","","",13,[[]]],[11,"into_bits","","",13,[[]]],[11,"vzip","","",13,[[]]],[11,"from","","",14,[[]]],[11,"from","","",14,[[]]],[11,"into","","",14,[[]]],[11,"to_owned","","",14,[[]]],[11,"clone_into","","",14,[[]]],[11,"try_from","","",14,[[],["result",4]]],[11,"try_into","","",14,[[],["result",4]]],[11,"borrow","","",14,[[]]],[11,"borrow_mut","","",14,[[]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"from_cast","","",14,[[]]],[11,"cast","","",14,[[]]],[11,"from_bits","","",14,[[]]],[11,"into_bits","","",14,[[]]],[11,"input","","",14,[[]]],[11,"result_reset","","",14,[[],["box",3]]],[11,"result","","",14,[[["box",3]],["box",3]]],[11,"reset","","",14,[[]]],[11,"output_size","","",14,[[]]],[11,"box_clone","","",14,[[],[["box",3],["dyndigest",8]]]],[11,"vzip","","",14,[[]]],[11,"from","scuttlebutt::bloomfilter","",4,[[]]],[11,"into","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from_cast","","",4,[[]]],[11,"cast","","",4,[[]]],[11,"from_bits","","",4,[[]]],[11,"into_bits","","",4,[[]]],[11,"vzip","","",4,[[]]],[11,"from","scuttlebutt::channel","",5,[[]]],[11,"into","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from_cast","","",5,[[]]],[11,"cast","","",5,[[]]],[11,"from_bits","","",5,[[]]],[11,"into_bits","","",5,[[]]],[11,"vzip","","",5,[[]]],[11,"from","scuttlebutt::cointoss","",9,[[]]],[11,"into","","",9,[[]]],[11,"to_string","","",9,[[],["string",3]]],[11,"try_from","","",9,[[],["result",4]]],[11,"try_into","","",9,[[],["result",4]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"from_cast","","",9,[[]]],[11,"cast","","",9,[[]]],[11,"from_bits","","",9,[[]]],[11,"into_bits","","",9,[[]]],[11,"vzip","","",9,[[]]],[11,"from","scuttlebutt::commitment","",10,[[]]],[11,"into","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"try_into","","",10,[[],["result",4]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"from_cast","","",10,[[]]],[11,"cast","","",10,[[]]],[11,"from_bits","","",10,[[]]],[11,"into_bits","","",10,[[]]],[11,"vzip","","",10,[[]]],[11,"new","","",10,[[]]],[11,"input","","",10,[[]]],[11,"finish","","",10,[[]]],[11,"check","","",10,[[]]],[11,"as_mut","scuttlebutt","",0,[[]]],[11,"as_mut","","",3,[[]]],[11,"as_ref","","",0,[[]]],[11,"as_ref","","",3,[[]]],[11,"from","","",0,[[]]],[11,"from","","",0,[[["__m128i",3]]]],[11,"from","","",0,[[]]],[11,"from","","",0,[[]]],[11,"from","","",3,[[],["block512",3]]],[11,"from","","",3,[[],["block512",3]]],[11,"from","","",3,[[],["block512",3]]],[11,"from","","",3,[[["__m512i",3]],["block512",3]]],[11,"from","scuttlebutt::cointoss","",9,[[["error",3]]]],[11,"from","scuttlebutt","",14,[[]]],[11,"clone","","",1,[[],["aes128",3]]],[11,"clone","","",2,[[],["aes256",3]]],[11,"clone","","",0,[[],["block",3]]],[11,"clone","","",3,[[],["block512",3]]],[11,"clone","","",13,[[],["aesrng",3]]],[11,"clone","","",14,[[],["universaldigest",3]]],[11,"default","","",0,[[]]],[11,"default","","",3,[[]]],[11,"default","","",13,[[]]],[11,"cmp","","",0,[[],["ordering",4]]],[11,"cmp","","",3,[[],["ordering",4]]],[11,"eq","","",0,[[["block",3]]]],[11,"eq","","",3,[[["block512",3]]]],[11,"eq","scuttlebutt::bloomfilter","",4,[[["bloomfilter",3]]]],[11,"ne","","",4,[[["bloomfilter",3]]]],[11,"partial_cmp","scuttlebutt","",0,[[],[["option",4],["ordering",4]]]],[11,"partial_cmp","","",3,[[],[["option",4],["ordering",4]]]],[11,"partial_cmp","scuttlebutt::bloomfilter","",4,[[["bloomfilter",3]],[["option",4],["ordering",4]]]],[11,"lt","","",4,[[["bloomfilter",3]]]],[11,"le","","",4,[[["bloomfilter",3]]]],[11,"gt","","",4,[[["bloomfilter",3]]]],[11,"ge","","",4,[[["bloomfilter",3]]]],[11,"fmt","scuttlebutt","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","scuttlebutt::bloomfilter","",4,[[["formatter",3]],["result",6]]],[11,"fmt","scuttlebutt::cointoss","",9,[[["formatter",3]],["result",6]]],[11,"fmt","scuttlebutt","",13,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","scuttlebutt::cointoss","",9,[[["formatter",3]],["result",6]]],[11,"bitand","scuttlebutt","",0,[[]]],[11,"bitor","","",0,[[]]],[11,"bitxor","","",0,[[]]],[11,"bitxor","","",3,[[]]],[11,"bitand_assign","","",0,[[]]],[11,"bitor_assign","","",0,[[]]],[11,"bitxor_assign","","",0,[[]]],[11,"bitxor_assign","","",3,[[]]],[11,"hash","","",0,[[]]],[11,"hash","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"read","","",6,[[],["result",6]]],[11,"read","","",7,[[],["result",6]]],[11,"read","scuttlebutt::channel","",5,[[],["result",6]]],[11,"read_vectored","","",5,[[],["result",6]]],[11,"read_to_end","","",5,[[["vec",3]],["result",6]]],[11,"read_to_string","","",5,[[["string",3]],["result",6]]],[11,"read_exact","","",5,[[],["result",6]]],[11,"write","scuttlebutt","",6,[[],["result",6]]],[11,"flush","","",6,[[],["result",6]]],[11,"write","","",7,[[],["result",6]]],[11,"flush","","",7,[[],["result",6]]],[11,"write","scuttlebutt::channel","",5,[[],["result",6]]],[11,"flush","","",5,[[],["result",6]]],[11,"write_vectored","","",5,[[],["result",6]]],[11,"write_all","","",5,[[],["result",6]]],[11,"write_fmt","","",5,[[["arguments",3]],["result",6]]],[11,"next_u32","scuttlebutt","",13,[[]]],[11,"next_u64","","",13,[[]]],[11,"fill_bytes","","",13,[[]]],[11,"try_fill_bytes","","",13,[[],[["result",4],["error",3]]]],[11,"input","","",14,[[["asref",8]]]],[11,"fixed_result","","",14,[[],["genericarray",3]]],[11,"reset","","",14,[[]]],[11,"from_seed","","",13,[[]]],[11,"from_rng","","",13,[[["rngcore",8]],[["result",4],["error",3]]]],[11,"serialize","","",0,[[["serializer",8]],["result",4]]],[11,"deserialize","","",0,[[["deserializer",8]],["result",4]]]],"p":[[3,"Block"],[3,"Aes128"],[3,"Aes256"],[3,"Block512"],[3,"BloomFilter"],[3,"Channel"],[3,"HashChannel"],[3,"TrackChannel"],[8,"AbstractChannel"],[4,"Error"],[3,"ShaCommitment"],[8,"Commitment"],[3,"AesHash"],[3,"AesRng"],[3,"UniversalDigest"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);